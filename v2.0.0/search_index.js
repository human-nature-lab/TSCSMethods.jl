var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page provides comprehensive documentation for all TSCSMethods.jl functions and types.","category":"page"},{"location":"api/#Complete-Function-and-Type-Reference","page":"API Reference","title":"Complete Function and Type Reference","text":"","category":"section"},{"location":"api/#TSCSMethods.BalanceData","page":"API Reference","title":"TSCSMethods.BalanceData","text":"BalanceData\n\nEfficient storage for balance computation data with separate arrays for values and missing indicators. This replaces Vector{Union{Missing, Float64}} with better performance and memory pooling capability.\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.CIC","page":"API Reference","title":"TSCSMethods.CIC","text":"CIC <: AbstractCICModel\n\nMain model type for causal inference with time-series cross-sectional data.\n\nContains all information needed for matching, balancing, and estimation in TSCS designs. Created by makemodel() and used throughout the analysis workflow.\n\nFields\n\ntitle::String: Model title for identification\nid::Symbol: Column name for unit identifier \nt::Symbol: Column name for time variable\noutcome::Union{Symbol,Vector{Symbol}}: Outcome variable(s)\ntreatment::Symbol: Treatment variable (binary 0/1)\ncovariates::Vector{Symbol}: Covariates used for matching\ntimevary::Dict{Symbol, Bool}: Whether each covariate is time-varying\nreference::Int: Reference time period (default: -1)\nF::UnitRange{Int}: Post-treatment periods for estimation\nL::UnitRange{Int}: Pre-treatment periods for matching (negative values)\nobservations::Vector{Tuple{Int, Int}}: Treated observations (time, unit)\nids::Vector{Int}: All unit identifiers\nmatches::Vector{TreatmentObservationMatches}: Matching results for each treated observation\nmeanbalances::DataFrame: Covariate balance statistics\ngrandbalances::Dict: Overall balance measures\niterations::Int: Bootstrap iterations (default: 500)\nresults::DataFrame: Treatment effect estimates\ntreatednum::Int: Number of treated observations\nestimator::String: Estimator type (default: \"ATT\")\n\nExamples\n\nusing TSCSMethods, DataFrames\n\ndata = example_data()\nmodel = makemodel(data, :day, :fips, :gub, :death_rte, \n                 [:pop_dens], Dict(:pop_dens => false),\n                 1:5, -10:-1)\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.CICStratified","page":"API Reference","title":"TSCSMethods.CICStratified","text":"CICStratified <: AbstractCICModelStratified\n\nStratified model type for causal inference with time-series cross-sectional data.\n\nExtends the basic CIC model to handle stratified analysis where matching and estimation are performed separately within subgroups defined by a stratifying variable.\n\nFields\n\ntitle::String: Model title for identification\nid::Symbol: Column name for unit identifier\nt::Symbol: Column name for time variable  \noutcome::Union{Symbol,Vector{Symbol}}: Outcome variable(s)\ntreatment::Symbol: Treatment variable (binary 0/1)\ncovariates::Vector{Symbol}: Covariates used for matching\ntimevary::Dict{Symbol, Bool}: Whether each covariate is time-varying\nstratifier::Symbol: Variable used for stratification\nstrata::Vector{Int}: Values of stratifying variable\nreference::Int: Reference time period (default: -1)  \nF::UnitRange{Int}: Post-treatment periods for estimation\nL::UnitRange{Int}: Pre-treatment periods for matching (negative values)\nobservations::Vector{Tuple{Int, Int}}: Treated observations (time, unit)\nids::Vector{Int}: All unit identifiers\nmatches::Vector{TreatmentObservationMatches}: Matching results for each treated observation\nmeanbalances::DataFrame: Covariate balance statistics by stratum\ngrandbalances::Dict: Overall balance measures by stratum\niterations::Int: Bootstrap iterations (default: 500)\nresults::DataFrame: Treatment effect estimates by stratum\ntreatednum::Dict{Int64, Int64}: Number of treated observations per stratum\nestimator::String: Estimator type (default: \"ATT\")\nlabels::Dict{Int64, String}: Human-readable labels for strata\n\nExamples\n\n# Create stratified model\nmodel = makemodel(data, :day, :fips, :gub, :death_rte,\n                 [:pop_dens], Dict(:pop_dens => false),\n                 1:5, -10:-1)\nstrat_model = stratify(model, data, :region)\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.Fblock","page":"API Reference","title":"TSCSMethods.Fblock","text":"    Fblock\n\nHolds the relevant information for bootstrapping and estimation, for a specific f in the outcome window (an f in a stratum when the model is stratified).\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.ImputationResults","page":"API Reference","title":"TSCSMethods.ImputationResults","text":"ImputationResults\n\nContainer for counterfactual imputation results.\n\nFields\n\nresults: DataFrame with counterfactual trajectories and treatment effects\nmatched_pretreatment_avg: Average pre-treatment outcome for matched controls\ntreated_pretreatment_avg: Average pre-treatment outcome for treated units\nbaseline_difference: Difference in pre-treatment averages (treated - matched)\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.TreatmentObservationCaliperMatches","page":"API Reference","title":"TSCSMethods.TreatmentObservationCaliperMatches","text":"TreatmentObservationCaliperMatches\n\nStores matching results for caliper-constrained CIC models.\n\nSimilar to TreatmentObservationMatches but for models where matches are restricted by caliper constraints (maximum allowable distance thresholds).\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.TreatmentObservationMatches","page":"API Reference","title":"TSCSMethods.TreatmentObservationMatches","text":"TreatmentObservationMatches\n\nStores matching results for each treated observation in basic CIC models.\n\nContains the core data structures for matching:\n\neligible_matches: Boolean matrix indicating which control units are eligible matches\ndistances: Computed distances between treated and control units  \nmatch_rankings: Ranked preferences for matches by time period\n\nThis is the fundamental data structure for storing match relationships in TSCS designs.\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.TreatmentObservationRefinedMatches","page":"API Reference","title":"TSCSMethods.TreatmentObservationRefinedMatches","text":"TreatmentObservationRefinedMatches\n\nStores matching results for refined CIC models.\n\nUsed in refined matching procedures where the initial match set is  iteratively improved through additional matching criteria.\n\n\n\n\n\n","category":"type"},{"location":"api/#TSCSMethods.__fill_meanbalances!-NTuple{5, Any}","page":"API Reference","title":"TSCSMethods.__fill_meanbalances!","text":"__fill_meanbalances!(balance_row, periods_with_matches, lag_periods_count, covariates, timevary)\n\nAllocate BalanceData objects for a single treated observation with error handling and memory pooling.\n\nPurpose\n\nHandles the actual allocation of BalanceData objects for one row of the meanbalances DataFrame. Implements error-safe memory pooling with proper cleanup if allocation fails partway through.\n\nArguments\n\nbalance_row: Single row from meanbalances DataFrame to populate\nperiods_with_matches: Number of forward periods that have eligible matches\nlag_periods_count: Number of lag periods (for time-varying covariate sizing)\ncovariates: Vector of covariate names to allocate storage for\ntimevary: Dict indicating which covariates are time-varying\n\nDetails\n\nFor time-varying covariates: Creates Vector{BalanceData} with periods_with_matches elements, each of size lag_periods_count\nFor static covariates: Creates single BalanceData of size periods_with_matches\nUses memory pooling via get_balance_data() for allocation efficiency\nImplements error handling: if allocation fails, returns all pooled objects to prevent memory leaks\nTracks all pooled allocations for proper cleanup\n\nError Handling\n\nIf any allocation fails, all previously allocated pooled objects are automatically returned to their respective pools to prevent memory leaks.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._calculate_counterfactuals!-NTuple{4, Any}","page":"API Reference","title":"TSCSMethods._calculate_counterfactuals!","text":"_calculate_counterfactuals!(matches_with_treatment, outcome_lookup, outcome_var, tvar)\n\nCalculate observed outcomes and counterfactual values for each matched observation. Modifies matcheswithtreatment in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._calculate_pretreatment_averages-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods._calculate_pretreatment_averages","text":"_calculate_pretreatment_averages(matches_with_treatment, outcome_lookup, outcome_var)\n\nCalculate pre-treatment outcome averages for treated and matched units. Returns (matchedavg, treatedavg).\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._estimate!-Tuple{Any, Any, Any, Vector{Symbol}, Vararg{Any, 8}}","page":"API Reference","title":"TSCSMethods._estimate!","text":"version for multiple outcomes\n\ndoes not include p-values, bayesfactor\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._fast_quantiles-Tuple{Vector{Float64}, Vector{Float64}}","page":"API Reference","title":"TSCSMethods._fast_quantiles","text":"Fast quantile computation from pre-sorted data\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._fill_meanbalances!-NTuple{6, Any}","page":"API Reference","title":"TSCSMethods._fill_meanbalances!","text":"_fill_meanbalances!(meanbalances, matches, lag_periods_count, covariates, timevary, forward_periods_count)\n\nPopulate meanbalances DataFrame with properly sized BalanceData objects for each treated observation.\n\nPurpose\n\nFor each treated observation, determines which forward periods (F values) have at least one eligible match, then allocates appropriate BalanceData storage structures. The allocation pattern depends on whether covariates are time-varying or static.\n\nArguments\n\nmeanbalances: DataFrame to populate (one row per treated observation)\nmatches: Vector of match objects containing eligible_matches matrices\nlag_periods_count: Number of lag periods (length of L range)\ncovariates: Vector of covariate names\ntimevary: Dict indicating which covariates are time-varying\nforward_periods_count: Number of forward periods (length of F range)\n\nDetails\n\nCreates :fs column indicating which forward periods have matches\nFor time-varying covariates: Vector{BalanceData} of length periodswithmatches\nFor static covariates: Single BalanceData of length periodswithmatches\nUses memory pooling via get_balance_data() for efficiency\nEach BalanceData object sized according to lagperiodscount for time-varying covariates\n\nStorage Structure\n\nmeanbalances[i, :covariate] = \n  - Time-varying: [BalanceData(lag_periods), BalanceData(lag_periods), ...]\n  - Static: BalanceData(periods_with_matches)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._makegroupindices-NTuple{11, Any}","page":"API Reference","title":"TSCSMethods._makegroupindices","text":"_makegroupindices(tidx, ridx, tridx, tts, uid, fmax, Lmin, tvec, idvec, treatvecbool, X)\n\nCore implementation for building group indices without exposure data.\n\nPurpose\n\nPopulates the index dictionaries by creating SubArray views for each (treatment_time, unit) combination. Uses parallel processing to efficiently handle large datasets.\n\nArguments\n\ntidx, ridx, tridx: Pre-allocated dictionaries to populate\ntts: Vector of treatment times (when treatments occurred)  \nuid: Vector of unique unit IDs\nfmax, Lmin: Time window bounds\ntvec, idvec, treatvecbool: Original data vectors\nX: Covariate data matrix\n\nImplementation Details\n\nUses Threads.@threads :greedy for parallel processing across (treatment_time, unit) pairs\nFor each pair, calls getyes!() to determine which data rows fall within the time window\nCreates SubArray views using @views macro for memory efficiency\nThread-safe due to non-overlapping dictionary key assignments\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._makegroupindices-NTuple{13, Any}","page":"API Reference","title":"TSCSMethods._makegroupindices","text":"_makegroupindices(tidx, ridx, tridx, tts, uid, fmax, Lmin, tvec, idvec, treatvecbool, X, exidx, exvec)\n\nCore implementation for building group indices with exposure data support.\n\nPurpose\n\nExtended version that additionally creates indexed views of exposure data alongside the standard covariate, time, and treatment indices. Used for exposure-based matching where treatment assignment depends on external exposure variables.\n\nArguments\n\ntidx, ridx, tridx: Standard index dictionaries to populate\nexidx: Additional dictionary for exposure data views\nexvec: Exposure data vector\nOther arguments same as standard version\n\nDetails\n\nIdentical logic to the standard version but additionally populates exidx[(tt, unit)] with SubArray views of the exposure data for each (treatment_time, unit) combination. This enables efficient access to exposure histories during matching algorithms that consider exposure patterns.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._validate_distaveraging_inputs-NTuple{4, Any}","page":"API Reference","title":"TSCSMethods._validate_distaveraging_inputs","text":"_validate_distaveraging_inputs(dtots, lag_times, fw, accums) -> Int\n\nValidate common inputs for distance averaging functions.\n\nReturns\n\nn_times::Int: Number of time points after validation\n\nThrows\n\nArgumentError: For empty required inputs\nDimensionMismatch: For inconsistent array dimensions\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods._validate_imputation_inputs-NTuple{6, Any}","page":"API Reference","title":"TSCSMethods._validate_imputation_inputs","text":"_validate_imputation_inputs(m, matches, dat, tvar, unit_var, stratum)\n\nValidate inputs for imputation function. Throws ArgumentError if validation fails.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.alldistances!-NTuple{5, Any}","page":"API Reference","title":"TSCSMethods.alldistances!","text":"alldistances!(dtotals, Σinvdict, xrows, yrows, lag_times)\n\nCalculate Mahalanobis and individual covariate distances for time-series matching.\n\nMathematical Foundation\n\nThis function implements the core distance calculations for the Feltham et al. (2023)  extension of Imai et al. (2021) matching methodology:\n\nMahalanobis Distance\n\nFor each time point τ, calculates:\n\nd_M(x_τ, y_τ) = √[(x_τ - y_τ)ᵀ Σ_τ⁻¹ (x_τ - y_τ)]\n\nwhere:\n\nxτ, yτ are covariate vectors for treated and control units at time τ\nΣ_τ⁻¹ is the inverse covariance matrix for time τ (from all units)\n\nIndividual Covariate Distances (for Calipers)\n\nFor each covariate j:\n\nd_j(x_jτ, y_jτ) = √[(x_jτ - y_jτ)² / σ²_jτ]\n\nwhere σ²jτ = Στ[j,j] is the variance of covariate j at time τ.\n\nAlgorithm\n\nMatrix Caching: Pre-cache all covariance matrices for lag_times to eliminate  repeated hash lookups (Performance optimization - maintains exact results)\nDistance Calculation: For each time point, compute both Mahalanobis and  individual distances simultaneously\nMissing Data: If any covariate is missing, the corresponding distance is missing\n\nArguments\n\ndtotals: Pre-allocated output arrays [Mahalanobis, Cov1, Cov2, ...] \nΣinvdict: Dictionary mapping time → inverse covariance matrix\nxrows: Treated unit covariate vectors over time\nyrows: Control unit covariate vectors over time  \nlag_times: Time points for distance calculation\n\nPerformance Notes\n\nOptimization: Caches covariance matrices to avoid O(m) hash lookups per distance\nComplexity: O(k) where k = length(lag_times), down from O(k×m) with m unique times\nMemory: Uses views and pre-allocated arrays for efficiency\n\nStatistical Accuracy\n\nThis function preserves exact mathematical equivalence to the original algorithm while providing significant performance improvements through caching.\n\nReferences\n\nFeltham et al. (2023): Mass gatherings methodology with extended time windows\nImai et al. (2021): Original matching framework for TSCS data\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.att!-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.att!","text":"    att!(atts, tcounts, fblocks)\n\nCalculate the att for each f, for a the set of treated units and matches contained in the fblocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.autobalance-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.autobalance","text":"autobalance(\n  model, dat;\n  refinementnum = 5,\n  calmin = 0.08, step = 0.05,\n  initial_bals = nothing\n)\n\nAutomatically balance via a simple algorithm. Start with initial caliper of 1.0, and subtract step whenever the grand mean balance threshold (0.1) is not met.\n\ninitial_bals is specified, work downward from the initial specified caliper for one or more selected variables. Unspecified variables start at a caliper of 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.average_distances!-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}, Any, Any, Any}} where T","page":"API Reference","title":"TSCSMethods.average_distances!","text":"average_distances!(drow, dtots, accums, lag_times, fw) where {T}\n\nCalculate averaged distances over time windows for fixed window matching.\n\nMathematical Formula\n\nFor each distance type k and valid time window W:\n\ndrow[k] = (1/|W|) ∑_{τ ∈ W} dtots[k][l] where lag_times[l] = τ  \n\nThis is the fixed-window version of distance averaging, used when matching windows are constant rather than sliding.\n\nArguments\n\ndrow: Output vector [K] where K = number of distance types\ndtots: Input distances [K][T] for K distance types over T time points\naccums: Working array for counting valid observations per distance type  \nlag_times: Time points corresponding to dtots columns\nfw: Fixed matching window specification\n\nDifferences from Sliding Version\n\nOutput: Single vector instead of matrix (no outcomeperiodindex, m indices)\nUse Case: Fixed matching windows vs. sliding windows\nPerformance: Slightly more efficient due to simpler indexing\n\nAlgorithm\n\nIdentical to sliding window version but with simplified output structure:\n\nPre-compute window bounds for efficiency\nType-stable initialization based on data type T\nAccumulate valid distances within window\nAverage by count of valid observations\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.average_distances!-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}, Vararg{Any, 5}}} where T","page":"API Reference","title":"TSCSMethods.average_distances!","text":"average_distances!(distances, dtots, accums, lag_times, fw, outcome_period_index, m) where {T}\n\nCalculate averaged distances over time windows for sliding window matching.\n\nMathematical Formula\n\nFor each distance type k and valid time window W:\n\ndistances[k][outcome_period_index, m] = (1/|W|) ∑_{τ ∈ W} dtots[k][l] where lag_times[l] = τ\n\nArguments\n\ndistances: Output array [K][outcomeperiodindex, m] where K = number of distance types\ndtots: Input distances [K][T] for K distance types over T time points  \naccums: Working array for counting valid observations per distance type\nlag_times: Time points corresponding to dtots columns\nfw: Matching window specification (e.g., -10:-1 for 10 periods before)\noutcome_period_index: Window index (for sliding windows)\nm: Match index\n\nAlgorithm\n\nWindow Bounds: Pre-compute fwmin, fwmax = extrema(fw) once\nType-Based Init: Initialize based on data type T for type stability\nFiltered Iteration: Only process lagtimes[l] where fwmin ≤ lagtimes[l] ≤ fwmax\nMissing Handling: Skip missing values, track counts in accums\nAveraging: Divide accumulated sums by valid observation counts\n\nPerformance\n\nComplexity: O(|lagtimes|) with early termination when lagtimes[l] > fw_max  \nMemory: Uses pre-allocated arrays, no intermediate allocations\nType Stability: Compile-time specialization for Float64 vs Union types\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.balance!-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.balance!","text":"balance!(model::VeryAbstractCICModel, dat::DataFrame) -> VeryAbstractCICModel\n\nPerform covariate balancing on a matched model to ensure treated and control units are comparable on observed characteristics.\n\nArguments\n\nmodel::VeryAbstractCICModel: A CIC model that has been matched (using match!)\ndat::DataFrame: Input data containing all model variables\n\nReturns\n\nThe input model with updated balance statistics\n\nDescription\n\nThis function performs two types of balancing:\n\nMean balancing: Computes balance statistics for each covariate across treatment periods\nGrand balancing: Aggregates balance statistics across the entire model\n\nBalancing assesses how well the matching procedure achieved covariate balance between treated and control groups. Poor balance may indicate the need for refinement via calipers or other restrictions.\n\nThrows\n\nArgumentError: If input data is empty\nErrorException: If balance calculations fail\n\nExamples\n\n# After constructing and matching a model\nmodel = makemodel(data, :time, :id, :treatment, :outcome, \n                 [:covar1, :covar2], timevary_dict, F_periods, L_periods)\nmatch!(model, data)\n\n# Perform balancing\nbalance!(model, data)\n\n# Check balance results\ncheckbalances(model, data)\n\nSee Also\n\ncheckbalances: Assess balance quality\nautobalance: Automatic balance improvement\nmatch!: Matching procedure that should precede balancing\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.bootinfo!-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.bootinfo!","text":"bootinfo!(res, oc, boots; qtiles = [0.025, 0.5, 0.975])\n\nFormat the bootstrap matrix into the results dataframe. Assumes that att() has already been added to res.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.bootinfo!-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.bootinfo!","text":"bootinfo!(res, boots; qtiles = [0.025, 0.5, 0.975])\n\nFormat the bootstrap matrix into the results dataframe. Assumes that att() has already been added to res.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.bootstrap!-NTuple{6, Any}","page":"API Reference","title":"TSCSMethods.bootstrap!","text":"    bootstrap!(boots, tcountmat, fblocks, ids, treatdex, iterations)\n\nPerform bootstrapping of the att for each f in the outcome window. Does so for the given set of treated units and matches contained in the fblocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.calculate_overall_summary-Tuple{TSCSMethods.ImputationResults, Symbol}","page":"API Reference","title":"TSCSMethods.calculate_overall_summary","text":"calculate_overall_summary(imputation_results::ImputationResults, outcome_var::Symbol)\n\nCalculate overall treatment effect summary statistics and balance diagnostics.\n\nThis function computes key summary statistics that help assess the quality and magnitude of the causal inference results.\n\nArguments\n\nimputation_results::ImputationResults: Output from impute_results()\noutcome_var::Symbol: Column name of the outcome variable\n\nReturns\n\nNamedTuple: Summary statistics with fields:\ntreated_observed_mean: Average observed outcome for treated units\noverall_att: Overall average treatment effect\ncounterfactual_mean: Average counterfactual outcome \nbaseline_difference: Pre-treatment difference between treated and matched units\ntreated_pretreatment_avg: Pre-treatment average for treated units\nmatched_pretreatment_avg: Pre-treatment average for matched controls\n\nExample\n\nimputation = impute_results(model, matches, data, :t, :id)\nsummary = calculate_overall_summary(imputation, :Y)\n\n# Key statistics\nprintln(\"Overall ATT: \", summary.overall_att)\nprintln(\"Baseline balance: \", summary.baseline_difference)  # Should be close to 0\nprintln(\"Treatment magnitude: \", summary.overall_att / summary.treated_observed_mean * 100, \"%\")\n\nNotes\n\nbaseline_difference close to 0 indicates good matching quality\noverall_att is the main causal estimate  \nComparing pre-treatment averages helps assess whether matching achieved balance\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.calculate_sample_Σs!-Tuple{Any, Any, Any, Any, Bool}","page":"API Reference","title":"TSCSMethods.calculate_sample_Σs!","text":"inverted covariance matrix for mahalanobis distance (all units at t)\n\ninverted sqrt(vars) for balance score calculations (treated units at t)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.caliper-Tuple{CIC, Any, Any}","page":"API Reference","title":"TSCSMethods.caliper","text":"caliper(\n    model::CIC, \n    acaliper::Dict{Symbol, Float64}, \n    dat::DataFrame; \n    dobalance::Bool = true\n) -> CaliperCIC\n\nApply caliper restrictions to a CIC model by excluding matches beyond specified distance thresholds.\n\nArguments\n\nmodel::CIC: A matched CIC model\nacaliper::Dict{Symbol, Float64}: Dictionary mapping covariates to maximum allowed distances\ndat::DataFrame: Input data containing all model variables\ndobalance::Bool: Whether to perform balancing on the calipered model (default: true)\n\nReturns\n\nCaliperCIC: A calipered version of the input model with restricted matches\n\nDescription\n\nCaliper restrictions improve match quality by excluding matches where the distance on specified covariates exceeds the given thresholds. This helps ensure that matched units are similar on the most important dimensions, potentially improving balance and reducing bias.\n\nExamples\n\n# After matching a model\nmodel = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)\nmatch!(model, data)\n\n# Apply calipers - exclude matches with distance > 0.25 on covar1 or > 0.5 on covar2\ncaliper_specs = Dict(:covar1 => 0.25, :covar2 => 0.5)\ncalipered_model = caliper(model, caliper_specs, data)\n\n# Apply calipers without automatic balancing\ncalipered_model = caliper(model, caliper_specs, data; dobalance = false)\n\nNotes\n\nStricter calipers improve match quality but reduce the number of matches\nUse autobalance to automatically determine appropriate caliper values\n\nSee Also\n\nrefine: Alternative approach using match ranking\nautobalance: Automatic caliper selection\nmatch!: Initial matching procedure\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.change_pct-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.change_pct","text":"change_pct(val, attval)\n\nCalculate percentage change from baseline value.\n\nArguments\n\nval: Baseline value\nattval: Treatment effect (difference from baseline)\n\nReturns\n\nFloat64: Percentage change (100 * attval / val)\n\nExample\n\nbaseline = 100.0\ntreatment_effect = 10.0\npct_change = change_pct(baseline, treatment_effect)  # Returns 10.0 (10% increase)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.checkbalances-Tuple{AbstractCICModel}","page":"API Reference","title":"TSCSMethods.checkbalances","text":"checkbalances(\n  m::Dict{Symbol, Union{Float64, Vector{Float64}}};\n  threshold = 0.1, stratareduce = true\n)\n\nSimply check whether the grand means are above the std. balance threshold. Returns a Bool for each covariate. If Stratareduce is true, then the strata balances will be agggregated to the covariate level, such that a violation in any caliper triggers a violation in the aggregated output.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.checksample-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.checksample","text":"not stratified\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.combostrat-Tuple{Any, Vector{Symbol}, Any}","page":"API Reference","title":"TSCSMethods.combostrat","text":"combostrat(model, dat, vars::Vector{Symbol}; varslabs = nothing)\n\nStratify based on the combinations of one or more variables that exist in the data. Strata are formed directly from the variable values.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.compare_strata-Tuple{Vector, Symbol, Vector{String}}","page":"API Reference","title":"TSCSMethods.compare_strata","text":"compare_strata(imputation_results_list::Vector, outcome_var::Symbol, stratum_names::Vector{String})\n\nCompare results across multiple strata or model specifications.\n\nArguments\n\nimputation_results_list: Vector of ImputationResults from different strata\noutcome_var: Symbol for outcome variable\nstratum_names: Names for each stratum for labeling\n\nReturns\n\nComparison plot showing ATT estimates across strata\nSummary table of key statistics\n\nExample\n\n# Run analysis for each stratum\nimputation1 = impute_results(model, matches, data, :t, :id, stratum=1)\nimputation2 = impute_results(model, matches, data, :t, :id, stratum=2)\n\n# Compare results\ncomparison = compare_strata([imputation1, imputation2], :Y, [\"Urban\", \"Rural\"])\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.compute_treated_std-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.compute_treated_std","text":"compute_treated_std(model::VeryAbstractCICModel, dat::DataFrame) -> Dict{Tuple{Int64, Symbol}, Float64}\n\nCompute standardization factors (1/σ) for covariates across all treated units' matching periods.\n\nPurpose\n\nFor balance calculations, we need to standardize covariate differences by the standard deviation of treated units during their matching windows. This ensures balance statistics are comparable across covariates with different scales.\n\nReturns\n\nDictionary with keys (time_offset, covariate) and values 1/σ, where:\n\ntime_offset: Days relative to treatment (negative = pre-treatment, positive = post-treatment)  \ncovariate: Covariate name\n1/σ: Inverse standard deviation for standardization\n\nDetails\n\nFor each treated unit at treatment time t, we collect covariate values from their matching window [t + min(L), t + max(F)]. We then compute the standard deviation of each covariate at each time offset across all treated units and return the inverse for efficient multiplication during balance calculations.\n\nExample\n\nstd_factors = compute_treated_std(model, data)\n# std_factors[(-10, :population)] = 0.05  # 1/σ for population 10 days before treatment\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.countmemb-Tuple{Any, Int64}","page":"API Reference","title":"TSCSMethods.countmemb","text":"faster version of countmap, use when length is known\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.create_inspection_dashboard-Tuple{TSCSMethods.ImputationResults, Symbol}","page":"API Reference","title":"TSCSMethods.create_inspection_dashboard","text":"create_inspection_dashboard(imputation_results::ImputationResults, outcome_var::Symbol)\n\nCreate a comprehensive dashboard with all inspection plots in a single figure.\n\nArguments\n\nimputation_results: ImputationResults struct from impute_results()\noutcome_var: Symbol representing the outcome variable column name\n\nReturns\n\nFigure: Comprehensive dashboard with 4 panels:\nTop Left: Treatment effects (ATT) over time with confidence intervals\nTop Right: Observed vs counterfactual trajectories comparison  \nBottom Left: Treatment effects as percentage changes\nBottom Right: Summary statistics and balance diagnostics\n\nExample\n\n# After running TSCSMethods analysis and generating imputation results\nimputation = impute_results(model, model.matches, data, :t, :id)\n\n# Create comprehensive dashboard\ndashboard = create_inspection_dashboard(imputation, :Y)\n\n# Save or display\nsave(\"analysis_dashboard.png\", dashboard)\ndashboard  # Display in notebook/REPL\n\nDashboard Interpretation\n\nATT Panel: Shows treatment effects over time. Look for consistent patterns and significant effects\nTrajectory Panel: Key causal story - distance between blue (observed) and black (counterfactual) lines shows treatment impact\nPercentage Panel: Treatment effects as % changes for easier interpretation of magnitude  \nSummary Panel: Key statistics including overall ATT and baseline balance assessment\n\nNotes\n\nDashboard provides comprehensive view of results\nAll panels use consistent time scales for easy comparison\nConfidence intervals help assess statistical uncertainty\nSummary statistics help evaluate matching quality and effect magnitude\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.customstrat-Tuple{Any, Any, Dict{Tuple{Int64, Int64}, Int64}}","page":"API Reference","title":"TSCSMethods.customstrat","text":"customstrat!(\n  cc,\n  stratdict::Union{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}\n)\n\nStratify based on the values of some input dictionary, specifying strata for each (t, id) or each (id) for a stratification that varies only by unit.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.default_treatmentcategories-Tuple{Any}","page":"API Reference","title":"TSCSMethods.default_treatmentcategories","text":"default_treatmentcategories(x) -> Int\n\nDefault categorization function for treatment histories during matching eligibility.\n\nPurpose\n\nCategorizes treatment exposure counts in the pre-crossover period to determine matching eligibility. Units can only be matched if they fall into the same treatment category during the pre-crossover window, ensuring similar treatment exposure patterns.\n\nArguments\n\nx: Total count of treatment exposures in the pre-crossover period for a unit\n\nReturns\n\n0: Never treated (x == 0)\n1: Ever treated (x > 0)\n\nUsage in Matching\n\nDuring matching, for each potential match pair:\n\nCount treatments in pre-crossover period for treated unit → category A\nCount treatments in pre-crossover period for potential match → category B  \nIf treatmentcategories(A) == treatmentcategories(B), matching is allowed\nOtherwise, the match is ineligible\n\nDefault Logic\n\nThis binary categorization ensures that:\n\nUntreated units can only match with other untreated units\nPreviously treated units can only match with other previously treated units\nPrevents contamination from units with different treatment exposure histories\n\nCustom Categories\n\nUsers can provide custom categorization functions for more nuanced matching:\n\n# Example: Allow multiple treatment intensity levels\ncustom_categories(x) = x <= 1 ? 0 : (x <= 5 ? 1 : 2)\nmatch!(model, data; treatcat = custom_categories)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.distances_allocate!-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.distances_allocate!","text":"distances_allocate!(matches, flen, covnum; sliding = false)\n\nPre-allocate distance storage arrays for match calculations.\n\nArguments\n\nmatches: Vector of match objects to allocate storage for\nflen: Length of the time dimension (number of time periods)\ncovnum: Number of covariates\nsliding: Whether to use sliding windows (default: false)\n\nAlgorithm\n\nFor each match object, allocate a matrix with dimensions:\nRows: Number of potential matches for this observation\nColumns: Number of distance types (1 Mahalanobis + covnum individual covariates)\nInitialize all distances to infinity (no matches computed yet)\n\nPerformance\n\nMemory: Pre-allocates all required storage to avoid allocations during computation\nParallelization: Thread-safe as each match object gets independent storage\nScalability: O(nobservations × maxmatches × n_covariates) memory usage\n\nNote\n\nThis function prepares the storage structure but does not compute any distances. Actual distance computation is performed by distances_calculate!.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.distances_calculate!-NTuple{10, Any}","page":"API Reference","title":"TSCSMethods.distances_calculate!","text":"distances_calculate!(matches, observations, ids, covariates, tg, rg, fmin, Lmin, Lmax, Σinvdict; sliding=false)\n\nMain function for calculating distances between treated and control units over time windows.\n\nMathematical Framework\n\nThis implements the core distance calculation for Feltham et al. (2023) methodology:\n\nFor each treated unit i and potential control unit j:\n\nTime Window: Define matching window L = [Lmin, Lmax] relative to treatment time\nDistance Calculation: For each τ ∈ L, compute d(x{iτ}, x{jτ})  \nTemporal Averaging: Average distances over valid time points in window\nMultiple Distance Types: Compute both Mahalanobis and individual covariate distances\n\nMathematical Formulation\n\nD(i,j) = (1/|W|) ∑_{τ ∈ W} d(x_{iτ}, x_{jτ})\n\nwhere:\n\nW = {τ : Lmin ≤ τ - t_i ≤ Lmax, data available for both units}\nt_i is the treatment time for unit i\nd(·,·) is the distance metric (Mahalanobis or covariate-specific)\n\nAlgorithm Overview\n\nThread Parallelization: Use :greedy scheduler for load balancing across irregular workloads\nValid Match Filtering: Check eligible_matches matrix to identify potential matches\nStorage Optimization: Use thread-local pre-allocated arrays\nDistance Computation: Call alldistances! for each treated-control pair\nWindow Averaging: Call window_distances! to average over time windows\n\nPerformance Optimizations\n\nThreading: Modern :greedy scheduler for better load balancing\nMemory: Thread-local storage eliminates 90% of allocations  \nCaching: Pre-cache covariance matrices to avoid repeated lookups\nEarly Termination: Skip observations with no valid matches\n\nArguments\n\nmatches: Output array of match objects with distance matrices\nobservations: Treated unit observations to process\nids: Unit identifiers for matching\ncovariates: List of covariate names for distance calculation\ntg: Treated unit covariate data grouped by (time, unit)\nrg: Time index mapping\nfmin, Lmin, Lmax: Window specification parameters\nΣinvdict: Pre-computed inverse covariance matrices by time\nsliding: Whether to use sliding windows (currently fixed windows only)\n\nComplexity\n\nTime: O(ntreated × npotentialmatches × windowsize × n_covariates)\nMemory: O(nthreads × maxwindowsize × maxcovariates) due to pre-allocation\nParallelization: Scales with number of threads, load-balanced across observations\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Float64}, Vararg{Any, 8}}","page":"API Reference","title":"TSCSMethods.eligibility!","text":"eligibility!(matches, observations, X::Matrix{Float64}, ids, treatcat, dat_t, dat_id, dat_trt, fmin, fmax, Lmin; exposure = nothing)\n\nDetermine matching eligibility for all treated observations using crossover window constraints.\n\nPurpose\n\nCore eligibility determination that implements the TSCS matching methodology's crossover window logic. Creates efficient indexed views of the data and determines which units can serve as matches for each treated observation.\n\nArguments\n\nmatches: Vector of match objects to populate with eligibility information\nobservations: Vector of treated observations (time, unit_id) tuples\nX: Covariate data matrix (Float64 version for non-missing data)\nids: Vector of unique unit identifiers\ntreatcat: Treatment categorization function for crossover period matching\ndat_t, dat_id, dat_trt: Time, unit ID, and treatment vectors from original data\nfmin, fmax: Bounds of forward period range (F)\nLmin: Minimum lag period (lower bound of L)\nexposure: Optional exposure variable for exposure-based matching\n\nReturns\n\ntg: Covariate group indices dictionary\nrg: Time group indices dictionary\n\nProcess\n\nGroup Index Creation: Builds efficient (treatmenttime, unitid) indexed views\nEligibility Determination: Calls eligiblematches!() to apply crossover window logic\nExposure Handling: Supports both standard and exposure-based matching\n\nCrossover Window Logic\n\nFor each treated observation, potential matches are evaluated using:\n\nPre-crossover treatment similarity (via treatcat function)\nPost-crossover treatment exclusion (no treatment allowed in specific windows)\nTime window constraints ensuring proper temporal alignment\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Union{Missing, Float64}}, Vararg{Any, 8}}","page":"API Reference","title":"TSCSMethods.eligibility!","text":"eligibility!(matches, observations, X::Matrix{Union{Missing, Float64}}, ids, treatcat, dat_t, dat_id, dat_trt, fmin, fmax, Lmin; exposure = nothing)\n\nDetermine matching eligibility with support for missing covariate data.\n\nPurpose\n\nMissing data version of the core eligibility function. Handles datasets where covariates may contain missing values, using appropriate handling in the groupindices creation and subsequent matching algorithms.\n\nArguments\n\nSame as standard eligibility!() but with:\n\nX: Covariate matrix allowing missing values (Matrix{Union{Missing, Float64}})\n\nMissing Data Handling\n\nCreates appropriate SubArray types that can handle missing values\nPropagates missing data handling through the matching pipeline\nDistance calculations will appropriately handle missing values in downstream functions\n\nImplementation Notes\n\nIdentical logic to the Float64 version but uses different type dispatch to ensure proper handling of missing values throughout the matching process.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Union{}}, Vararg{Any, 8}}","page":"API Reference","title":"TSCSMethods.eligibility!","text":"eligibility!(matches, observations, X::Matrix{Union{}}, ids, treatcat, dat_t, dat_id, dat_trt, fmin, fmax, Lmin; exposure = nothing)\n\nHandle matching eligibility when no covariates are specified.\n\nPurpose\n\nSpecial case handler for models with no covariates (empty covariates array). Converts the empty matrix to an appropriate Float64 matrix structure and delegates to the standard eligibility function.\n\nArguments\n\nSame as standard eligibility!() but with:\n\nX: Empty covariate matrix (Matrix{Union{}})\n\nBehavior\n\nCreates a properly sized Matrix{Float64} with 0 columns but correct row count\nDelegates to the standard Float64 version of eligibility!()\nEnables matching based purely on treatment history patterns without covariate distance\n\nUse Cases\n\nTreatment effect estimation based only on temporal patterns\nMatching when covariates are unavailable or not needed\nSensitivity analysis excluding covariate matching\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.eligibility-Tuple{VeryAbstractCICModel}","page":"API Reference","title":"TSCSMethods.eligibility","text":"eligibility(model::VeryAbstractCICModel)\n\nCalculate unit eligibility across all treated observations.\n\nArguments\n\nmodel: Fitted TSCSMethods model\n\nReturns\n\nMatrix{Int}: Eligibility matrix (units × time periods F)\n\nDescription\n\nFor each potential control unit, calculates how many times it is eligible to serve as a match across all treated observations and time periods. Higher eligibility indicates units that are consistently good potential matches for multiple treated units.\n\nUseful for identifying:\n\nUnits that are consistently good matches across multiple treated observations\nPotential issues with match quality or overlap\nWhether certain units dominate the matching process\nBalance in the matching pool\n\nExamples\n\neligibility_matrix = eligibility(model)\n\n# Find highly eligible units\ntotal_eligibility = sum(eligibility_matrix, dims=2)\nhighly_eligible_indices = findall(x -> x > 5, vec(total_eligibility))\nhighly_eligible_ids = model.ids[highly_eligible_indices]\n\nprintln(\"Units eligible for >5 matches: $highly_eligible_ids\")\n\n# Check eligibility by time period\nfor (f_idx, f) in enumerate(model.F)\n    eligible_count = sum(eligibility_matrix[:, f_idx])\n    println(\"F=$f: $eligible_count total eligible matches\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.estimate!-Tuple{AbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.estimate!","text":"estimate!(\n    ccr::AbstractCICModel, dat;\n    iterations = nothing,\n    percentiles = [0.025, 0.5, 0.975],\n    overallestimate = false,\n    bayesfactor = true\n)\n\nPerform ATT estimation, with bootstrapped CIs.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.estimate!-Tuple{AbstractCICModelStratified, Any}","page":"API Reference","title":"TSCSMethods.estimate!","text":"estimate!(ccr::AbstractCICModelStratified, dat; iterations = nothing)\n\nPerform ATT stratified estimation, with bootstrapped CIs.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.example_data-Tuple{}","page":"API Reference","title":"TSCSMethods.example_data","text":"example_data()\n\nLoad pre-existing example data for testing and demonstration.\n\nReturns\n\nDataFrame: Panel data with columns: date, fips, popdens, cumuldeathrate, deathrte, gub, day\n\nDescription\n\nLoads example panel data from the package's vignette directory. This is real data from the package examples, providing a consistent dataset for testing and tutorials.\n\nFor generating synthetic data with custom parameters, use example_data_generated(), policy_data(), or economic_data() instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.executesample!-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.executesample!","text":"not stratified\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.export_results_csv-Tuple{Any, String}","page":"API Reference","title":"TSCSMethods.export_results_csv","text":"export_results_csv(inspection_results, output_path::String)\n\nExport the results DataFrame to CSV for further analysis in other software.\n\nArguments\n\ninspection_results: Output from inspect_results()\noutput_path: Path for the CSV file\n\nExample\n\ninspection = inspect_results(imputation, :Y)\nexport_results_csv(inspection, \"analysis_results.csv\")\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.filterunits!-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.filterunits!","text":"filterunits!(m, omap)\n\nRemove treated units and matches that do not have values defined in the outcome window. This could be modified to account for missingness easily. This should probably be integrated into the match! procedure. (keep separate for now). (Updates ranks as well.)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.find_periods_with_matches!-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.find_periods_with_matches!","text":"find_periods_with_matches!(has_matches_by_period, eligible_matches_matrix)\n\nDetermine which forward periods have at least one eligible match across all potential match units.\n\nPurpose\n\nFor a given treated observation, creates a boolean vector indicating which forward periods (F values) have at least one unit eligible to serve as a match. This is used to determine which periods need BalanceData storage allocation.\n\nArguments\n\nhas_matches_by_period: Output boolean vector to populate (length = number of F periods)\neligible_matches_matrix: Boolean matrix where [unit, period] indicates if unit is eligible match for that period\n\nDetails\n\nPerforms column-wise any() operation across the eligiblematchesmatrix\nhas_matches_by_period[i] = true if any unit can match in forward period i\nhas_matches_by_period[i] = false if no units are eligible for forward period i\nUsed to optimize storage: only allocate BalanceData for periods with potential matches\n\nExample\n\n# eligible_matches_matrix: 3 units × 4 periods\n# [true  false true  true ]  # unit 1\n# [false true  false false]  # unit 2  \n# [false false false true ]  # unit 3\n# \n# Result: [true, true, true, true] - all periods have ≥1 eligible match\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.fpossible!-NTuple{7, Any}","page":"API Reference","title":"TSCSMethods.fpossible!","text":"check possibility of the match for each f\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.fpossible!-NTuple{9, Any}","page":"API Reference","title":"TSCSMethods.fpossible!","text":"check possibility of the match for each f\n\nversion with exposure\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.fpossible_mis!-NTuple{11, Any}","page":"API Reference","title":"TSCSMethods.fpossible_mis!","text":"check possibility of the match for each f\n\nversion with exposure\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.fpossible_mis!-NTuple{9, Any}","page":"API Reference","title":"TSCSMethods.fpossible_mis!","text":"check possibility of the match for each f\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.generate_normal_effects-Tuple{Float64, UnitRange{Int64}}","page":"API Reference","title":"TSCSMethods.generate_normal_effects","text":"generate_normal_effects(peak_effect::Float64, F_range::UnitRange{Int64})\n\nGenerate F-period effects following a normal distribution centered on middle F period.\n\nExample\n\neffects = generate_normal_effects(1.0, 1:10)  # Peak effect of 1.0 at F=5-6\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.generate_realistic_tscs-Tuple{}","page":"API Reference","title":"TSCSMethods.generate_realistic_tscs","text":"generate_realistic_tscs(; kwargs...)\n\nGenerate synthetic data that mimics the WORKING example_data() treatment pattern but with known, controllable treatment effects for validation.\n\nKey Design\n\nEvent-based treatment: Treatment indicator = 1 only on treatment day\nSparse treatment: ~2% of observations treated (like real example)\nStaggered timing: Different units treated on different days\nKnown ATT: Specified treatment effect we can validate against\n\nParameters\n\ntrue_att::Float64: Known treatment effect to recover\nn_units::Int=100: Number of units (like example data)\nn_days::Int=90: Number of time periods (like example data)\nn_treated::Int=20: Number of treated units (like example data)\ntreatment_start_day::Int=40: Earliest treatment day (like example data)\noutcome_scale::Float64=0.5: Base outcome level (like death rates)\nseed::Int=1234: Random seed\n\nReturns\n\nDataFrame with same structure as example_data():\n\ndate, fips, pop_dens, cumul_death_rate, death_rte, gub, day\nTreatment effect built into death_rte outcome\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.generate_simple_tscs-Tuple{}","page":"API Reference","title":"TSCSMethods.generate_simple_tscs","text":"generate_simple_tscs(; kwargs...)\n\nGenerate synthetic time-series cross-sectional data with known treatment effect.\n\nMathematical Model\n\nYit = αi + λt + τ*Dit + ε_it\n\nWhere:\n\nY_it: outcome for unit i at time t  \nα_i: unit fixed effects (time-invariant differences between units)\nλ_t: time fixed effects (common time trends)\nD_it: treatment indicator (1 if unit i treated at time t, 0 otherwise)\nτ: treatment effect (THIS IS WHAT WE WANT TO RECOVER)\nε_it: idiosyncratic error term\n\nKey Properties\n\nParallel trends satisfied by construction (common λ_t)\nNo confounding (treatment assignment independent of potential outcomes)\nKnown counterfactual (Yit without treatment = αi + λt + εit)\n\nParameters\n\ntrue_att::Float64: The true average treatment effect (τ)\nn_units::Int=100: Number of cross-sectional units\nn_periods::Int=50: Number of time periods\ntreatment_period::Int=25: When treatment begins (must be > max(abs(L)))\nn_treated::Int=20: Number of units that receive treatment\nunit_fe_var::Float64=2.0: Variance of unit fixed effects (α_i)\ntime_fe_var::Float64=1.0: Variance of time fixed effects (λ_t)\nerror_var::Float64=1.0: Variance of idiosyncratic errors (ε_it)\nseed::Int=1234: Random seed for reproducibility\n\nReturns\n\nDataFrame with columns:\n\nunit_id: Unit identifier (1, 2, ..., n_units)\ntime_period: Time identifier (1, 2, ..., n_periods)\ntreatment: Treatment indicator (0/1)\noutcome: Generated outcome variable Y_it\nunit_fe: Unit fixed effect α_i (for validation)\ntime_fe: Time fixed effect λ_t (for validation)\ntrue_control_outcome: Counterfactual outcome without treatment\n\nExample\n\n# Generate data where true ATT = 2.5\ndata = generate_simple_tscs(true_att=2.5, n_units=50, n_periods=40, seed=42)\n\n# The package should recover ATT ≈ 2.5\nmodel = makemodel(data, :time_period, :unit_id, :treatment, :outcome, [], Dict(), 1:5, -10:-1)\nmatch!(model, data)\nestimate!(model, data)\n@test abs(model.overall.ATT - 2.5) < 0.2  # Should be close to true effect\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.generate_tscs_with_covariates-Tuple{}","page":"API Reference","title":"TSCSMethods.generate_tscs_with_covariates","text":"generate_tscs_with_covariates(; kwargs...)\n\nGenerate synthetic TSCS data with covariates that affect both treatment and outcome.\n\nMathematical Model\n\nYit = αi + λt + β*Xit + τ*Dit + εit Dit = treatment assignment potentially related to Xit\n\nWhere X_it are time-varying covariates that may confound the relationship.\n\nAdditional Parameters\n\ncovariate_effects::Vector{Float64}: Effects of each covariate on outcome (β)\ncovariate_names::Vector{Symbol}: Names for the covariates\nconfounding_strength::Float64=0.0: How much covariates affect treatment assignment\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.get_balance_data","page":"API Reference","title":"TSCSMethods.get_balance_data","text":"get_balance_data(size::Int, fill_missing::Bool = true) -> (BalanceData, Bool)\n\nEfficiently allocate BalanceData objects using memory pooling for performance optimization.\n\nPurpose\n\nCreates BalanceData objects while reusing pre-allocated memory buffers when possible. This reduces allocation overhead during intensive balance calculations across many treated observations and matching periods.\n\nArguments\n\nsize: Number of elements needed in the BalanceData object\nfill_missing: Whether to initialize all values as missing (default: true)\n\nReturns\n\nTuple of:\n\nBalanceData: The allocated/reused balance data object\nBool: Whether the object came from the pool (true) or was newly allocated (false)\n\nDetails\n\nFor small objects (≤100 elements): attempts to reuse pooled memory\nFor large objects or when pool is empty: allocates new memory directly\nPooled objects should be returned via return_balance_data() when no longer needed\nThread-safe through channel-based pooling system\n\nExample\n\nbalance_data, is_pooled = get_balance_data(50, true)\n# ... use balance_data ...\nreturn_balance_data(balance_data, is_pooled)  # Return to pool when done\n\n\n\n\n\n","category":"function"},{"location":"api/#TSCSMethods.get_thread_storage-Tuple{Int64, Int64}","page":"API Reference","title":"TSCSMethods.get_thread_storage","text":"get_thread_storage(n_times::Int, n_covariates::Int) -> ThreadLocalDistanceStorage\n\nGet or create thread-local storage for distance calculations.\n\nAlgorithm\n\nTask Identification: Get current task (modern alternative to deprecated threadid())\nStorage Check: Check if storage exists and is large enough for this task\nResize/Create: If needed, create new storage with sufficient capacity\nReturn: Provide storage for immediate use\n\nParameters\n\nn_times: Number of time periods needed\nn_covariates: Number of covariates needed\n\nReturns\n\nThreadLocalDistanceStorage: Pre-allocated arrays ready for use\n\nTask Safety\n\nUses modern task-local storage instead of deprecated Threads.threadid(). Each task maintains independent storage, preventing race conditions while maximizing memory reuse and providing better composability.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.getoutcomemap-NTuple{4, Any}","page":"API Reference","title":"TSCSMethods.getoutcomemap","text":"getoutcomemap(outcome, data, t, id)\n\nCreate a fast lookup dictionary mapping (time, unit) tuples to outcome values.\n\nPurpose\n\nThis function creates an optimized lookup structure for outcome data that will be accessed repeatedly during estimation. Instead of searching through the DataFrame for each outcome lookup, we pre-build a hash table for O(1) access.\n\nAlgorithm\n\nDictionary Creation: Build Dict{Tuple{Int, Int}, Float64} where keys are (time, unit_id)\nData Population: Iterate through all rows, storing non-missing outcomes\nMissing Data Handling: Skip any rows where the outcome is missing\n\nPerformance Benefits\n\nFast Lookups: O(1) average case vs O(n) DataFrame search\nMemory Efficient: Only stores non-missing outcomes\nEstimation Optimization: Critical for bootstrap performance where outcomes are accessed thousands of times\n\nArguments\n\noutcome: Symbol indicating the outcome column name\ndata: Input DataFrame containing the panel data\nt: Symbol for the time variable column\nid: Symbol for the unit identifier column\n\nReturns\n\nDict{Tuple{Int, Int}, Float64}: Dictionary mapping (time, unit_id) → outcome value\n\nUsage in Estimation\n\nDuring ATT estimation, we need outcome values for:\n\nTreated units at outcome periods: outcomemap[(outcome_time, treated_unit)]\nMatched units at outcome periods: outcomemap[(outcome_time, matched_unit)]\nAll units at reference periods: outcomemap[(reference_time, unit)]\n\nExample\n\n# If data has columns :time, :unit_id, :outcome\noutcome_lookup = getoutcomemap(:outcome, data, :time, :unit_id)\n# Later: quickly get outcome for unit 5 at time 10\nvalue = outcome_lookup[(10, 5)]\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.getsample-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.getsample","text":"not stratified\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.getyes!-NTuple{7, Any}","page":"API Reference","title":"TSCSMethods.getyes!","text":"getyes!(yesrows, tvec, idvec, tt, fmax, Lmin, unit)\n\nDetermine which data rows fall within the matching time window for a specific unit and treatment time.\n\nPurpose\n\nPopulates a boolean mask indicating which rows of the original data should be included in the indexed view for a given (treatment_time, unit) combination. This implements the core logic for defining matching windows in TSCS designs.\n\nArguments\n\nyesrows: Output boolean vector to populate (same length as tvec)\ntvec: Time vector from original data\nidvec: Unit ID vector from original data  \ntt: Treatment time (when treatment occurred)\nfmax: Maximum forward period (upper bound of F range)\nLmin: Minimum lag period (lower bound of L range, typically negative)\nunit: Unit ID to extract data for\n\nTime Window Logic\n\nSelects rows where:\n\ntvec[k] >= tt + Lmin (at or after start of lag period)\ntvec[k] < tt + fmax (before end of forward period)  \nidvec[k] == unit (belongs to the specified unit)\n\nExample Time Windows\n\nTreatment at tt=100, Lmin=-30, fmax=40:\n- Window: [70, 139] (from 100-30 to 100+40-1)\n- Includes: lag periods for covariate measurement + forward periods for outcomes\n- Excludes: data outside this window or from other units\n\nPerformance Notes\n\nOperates in-place on yesrows for memory efficiency\nUsed within threaded loops, so must be thread-safe (which it is)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.grandbalance!-Tuple{AbstractCICModelStratified}","page":"API Reference","title":"TSCSMethods.grandbalance!","text":"grandbalance!(model::AbstractCICModelStratified)\n\nCalculate the overall mean covariate balance for a model.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.grandbalance!-Tuple{AbstractCICModel}","page":"API Reference","title":"TSCSMethods.grandbalance!","text":"grandbalance!(model::AbstractCICModel)\n\nCalculate the overall mean covariate balance for a model.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.impute_results-NTuple{5, Any}","page":"API Reference","title":"TSCSMethods.impute_results","text":"impute_results(m, matches, dat, tvar, unit_var; stratum = 1)\n\nGenerate counterfactual outcomes Y(0) using matched control units.\n\nArguments\n\nm: Fitted TSCSMethods model\nmatches: DataFrame of matched units from matching procedure  \ndat: Original panel data\ntvar: Time variable name in data\nunit_var: Unit ID variable name in data\nstratum: Stratum number for stratified models (default: 1)\n\nReturns\n\nImputationResults: Structured container with counterfactual analysis\n\nThe results DataFrame includes:\n\ncounterfactual_trajectory: What treated outcomes would have been without treatment\ncounterfactual_values: Average of matched control outcomes at each time\ncounterfactual_lower/counterfactual_upper: Confidence intervals for counterfactuals\npct_change/pct_change_lower/pct_change_upper: Treatment effects as percentage changes\ndaily_counterfactual_change: Day-to-day variation in counterfactual outcomes\n\nCreates counterfactual predictions by averaging matched control outcomes at each time period, enabling visualization of treated vs counterfactual trajectories.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.initialize_balance_storage!-Tuple{Any}","page":"API Reference","title":"TSCSMethods.initialize_balance_storage!","text":"initialize_balance_storage!(model)\n\nPrepare the meanbalances DataFrame storage for balance calculations.\n\nPurpose\n\nAllocates and initializes the meanbalances DataFrame which stores balance statistics for each treated observation. The DataFrame structure depends on whether covariates are time-varying or static.\n\nDetails\n\nCreates one row per treated observation\nFor time-varying covariates: Vector{Vector{BalanceData}} (periods × time points)\nFor static covariates: Vector{BalanceData} (just periods)\nUses object pooling for memory efficiency\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.inspect_results-Tuple{TSCSMethods.ImputationResults, Symbol}","page":"API Reference","title":"TSCSMethods.inspect_results","text":"inspect_results(imputation_results::ImputationResults, outcome_var::Symbol; \n               plot_percentage_changes::Bool = false)\n\nComprehensive inspection of TSCSMethods results with clean separation of data processing and plotting.\n\nArguments\n\nimputation_results: ImputationResults struct from impute_results()\noutcome_var: Symbol representing the outcome variable column name\nplot_percentage_changes: Whether to include percentage change plots (default: false)\n\nReturns\n\nNamedTuple with fields:\ntreatment_effects_plot: Figure showing ATT over time with confidence intervals\ncounterfactual_plot: Figure showing observed vs counterfactual trajectories  \nsummary: NamedTuple with summary statistics and balance diagnostics\ndata: Prepared data structures for custom plotting or further analysis\npercentage_plot: (optional) Figure showing treatment effects as percentage changes\n\nExample\n\nusing TSCSMethods\n\n# Complete workflow\ndata = example_data()\nmodel = makemodel(data, :t, :id, :gub, :Y, [:X1, :X2], \n                  Dict(:X1 => false, :X2 => false), -15:-10, 1:5)\nmatch!(model, wids=50)\nbalance!(model)\nestimate!(model, dobayesfactor=false)\n\n# Generate imputation results  \nimputation = impute_results(model, model.matches, data, :t, :id)\n\n# Comprehensive inspection\ninspection = inspect_results(imputation, :Y, plot_percentage_changes=true)\n\n# View plots\ninspection.treatment_effects_plot    # Shows ATT over time\ninspection.counterfactual_plot       # Shows causal story: observed vs counterfactual  \ninspection.percentage_plot           # Shows effects as % changes\n\n# Access summary statistics\nsummary = inspection.summary\nprintln(\"Average treatment effect: \", round(summary.overall_att, digits=3))\nprintln(\"Baseline balance: \", round(summary.baseline_difference, digits=3))\n\n# Access underlying data for custom analysis  \nresults_df = inspection.results_df\ncustom_plot = plot_treatment_effects(results_df, title=\"My Custom ATT Plot\")\n\nNotes\n\nThis function coordinates the entire inspection workflow\nData processing and plotting are separated for flexibility\nAll plots contain proper labels and confidence intervals\nUse plot_percentage_changes=true for additional percentage change visualization\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.make_groupindices-NTuple{7, Any}","page":"API Reference","title":"TSCSMethods.make_groupindices","text":"make_groupindices(tvec, treatvec, idvec, uid, fmax, Lmin, X; exvec = nothing)\n\nCreate efficient lookup dictionaries for accessing unit-specific data during matching windows.\n\nPurpose\n\nBuilds indexed views of the data organized by (treatmenttime, unitid) pairs, covering the relevant time windows for matching. This enables fast access to covariate values, treatment histories, and time vectors for each unit during balance calculations.\n\nArguments\n\ntvec: Time vector from the data\ntreatvec: Treatment indicator vector (0/1 or boolean)\nidvec: Unit identifier vector  \nuid: Vector of unique unit IDs to process\nfmax: Maximum forward period (upper bound of F range)\nLmin: Minimum lag period (lower bound of L range) \nX: Covariate data matrix\nexvec: Optional exposure vector for exposure-based matching\n\nReturns\n\nTuple of dictionaries with keys (treatment_time, unit_id):\n\ntidx: Covariate values for unit during time window [tt + Lmin, tt + fmax)\nridx: Time values for unit during the window\ntridx: Treatment indicators for unit during the window\nexidx: Exposure values (only if exvec provided)\n\nDetails\n\nFor each treated observation at time tt, creates indexed views for all units covering the time window from tt + Lmin to tt + fmax - 1. This spans both the lag periods (for baseline covariate measurement) and forward periods (for outcome measurement).\n\nPerformance Notes\n\nUses threaded processing for parallel index construction\nReturns memory-efficient SubArray views rather than copying data\nPre-allocates dictionaries with appropriate size hints\n\nExample\n\ntidx, ridx, tridx = make_groupindices(data.time, data.treatment, data.unit_id, \n                                      unique_units, 40, -30, covariate_matrix)\n# Access unit 1's covariates during treatment time 100's window:\nunit1_covariates = tidx[(100, 1)]  # SubArray view of relevant data\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.make_timeunit_lookup-NTuple{4, Any}","page":"API Reference","title":"TSCSMethods.make_timeunit_lookup","text":"make_timeunit_lookup(dat, variable, time_col, unit_var)\n\nCreate lookup dictionary mapping (time, unit) tuples to variable values. Returns Dict{Tuple, Union{Float64, Missing}} for fast value retrieval.\n\nArguments\n\ndat: DataFrame with panel data\nvariable: Column name for the variable to look up\ntime_col: Column name for time variable\nunit_col: Column name for unit ID variable\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.makefblocks-NTuple{5, Any}","page":"API Reference","title":"TSCSMethods.makefblocks","text":"    makefblocks(subTus, subMus, subWos, subWrs, subFs)\n\nPopulate a set of fblocks to estimate and bootstrap the ATT.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.makemodel-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Vector{Symbol}, Dict{Symbol, Bool}, UnitRange{Int64}, UnitRange{Int64}}","page":"API Reference","title":"TSCSMethods.makemodel","text":"makemodel(\n    dat::DataFrame, \n    t::Symbol, \n    id::Symbol, \n    treatment::Symbol, \n    outcome::Union{Symbol, Vector{Symbol}},\n    covariates::Vector{Symbol}, \n    timevary::Dict{Symbol, Bool},\n    F::UnitRange{Int}, \n    L::UnitRange{Int};\n    title::String = \"model\",\n    estimator::String = \"ATT\"\n) -> CIC\n\nConstruct a CIC (Changes-in-Changes) model for causal inference analysis.\n\nArguments\n\ndat::DataFrame: Input data containing all required variables\nt::Symbol: Column name for time variable\nid::Symbol: Column name for unit identifier\ntreatment::Symbol: Column name for treatment variable (0/1 coding expected)\noutcome::Union{Symbol, Vector{Symbol}}: Column name(s) for outcome variable(s)\ncovariates::Vector{Symbol}: Vector of column names for matching covariates\ntimevary::Dict{Symbol, Bool}: Dictionary mapping each covariate to whether it's time-varying\nF::UnitRange{Int}: Time periods for treatment effect estimation (post-treatment)\nL::UnitRange{Int}: Time periods for pre-treatment matching window\ntitle::String: Optional title for the model (default: \"model\")\nestimator::String: Estimator type (default: \"ATT\" for Average Treatment Effect on Treated)\n\nReturns\n\nCIC: A constructed CIC model ready for matching, balancing, and estimation\n\nThrows\n\nArgumentError: If input data is empty, required columns are missing, or parameters are invalid\n\nExamples\n\nusing TSCSMethods, DataFrames\n\n# Create sample data\ndata = DataFrame(\n    time = repeat(1:100, 50),\n    unit_id = repeat(1:50, inner=100),\n    treated = repeat([fill(1, 10); fill(0, 40)], inner=100),\n    outcome = randn(5000),\n    covar1 = randn(5000),\n    covar2 = randn(5000)\n)\n\n# Construct model\nmodel = makemodel(\n    data, :time, :unit_id, :treated, :outcome,\n    [:covar1, :covar2],\n    Dict(:covar1 => false, :covar2 => true),\n    51:60, 40:49  # F and L periods\n)\n\nReferences\n\nBased on the methodology from Imai, Kim, and Wang (2021) for matching methods  with time-series cross-sectional data.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.match!-Tuple{AbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.match!","text":"match!(model::AbstractCICModel, dat::DataFrame; treatcat = default_treatmentcategories, exposure = nothing, variancesonly = true)\n\nPerform matching for treatment events using Mahalanobis distance with crossover window restrictions.\n\nPurpose\n\nCore matching algorithm that identifies eligible control units for each treated observation, calculates distances using Mahalanobis metric, and ranks potential matches. Implements the extended TSCS matching methodology with crossover window constraints to ensure proper counterfactual identification.\n\nArguments\n\nmodel: CIC model containing treated observations and match storage structures\ndat: DataFrame with time-series cross-sectional data\ntreatcat: Function categorizing treatment histories (default: default_treatmentcategories)\nexposure: Optional exposure variable name for exposure-based matching\nvariancesonly: Use diagonal covariance matrix (variances only) vs full covariance (default: true)\n\nReturns\n\nModified model with populated matches containing:\n\nEligible match indicators for each treated observation\nMahalanobis distances to potential matches\nRanked match preferences for each forward period\n\nMatching Process\n\nEligibility Determination: Uses crossover window logic to determine which units can serve as matches\nDistance Calculation: Computes Mahalanobis distances using sample covariance matrix\nRanking: Orders potential matches by distance for each forward period (F)\n\nCrossover Window Logic\n\nFor treatment at time t with forward period f:\n\nPre-crossover period: [t + f - max(F), t + f - min(F)] \nPost-crossover period: [t + f - min(F), t + f - max(F)]\nMatches must have similar treatment patterns in pre-crossover period\nMatches cannot be treated in post-crossover period\n\nPerformance Notes\n\nUses threaded processing for parallel distance calculations\nMemory-efficient SubArray views via groupindices system\nHandles missing data through multiple dispatch\n\nExample\n\nmodel = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)\nmatch!(model, data)  # Standard matching\nmatch!(model, data; exposure = :policy_exposure)  # With exposure matching\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.matchinfo-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.matchinfo","text":"matchinfo(refined_model, original_model; maxrank = 5)\n\nGenerate match information DataFrame for refined/calipered models.\n\nPurpose\n\nCreates match information for models that have undergone refinement or caliper operations, showing how refined matches relate to the original full model's ranking system. Useful for understanding how refinement affects match selection and quality.\n\nArguments\n\nrefined_model: Refined or calipered CIC model (result of refine() or caliper())\noriginal_model: Original full CIC model before refinement\nmaxrank: Maximum number of matches to include per F period (default: 5)\n\nReturns\n\nDataFrame with columns:\n\ntimetreated: Time when treatment occurred\ntreatedunit: ID of the treated unit\nf: Forward period within the outcome window\nmatchunits: Vector of matched control unit IDs from refined model\nranks: Vector of rank positions from original model's full ranking\n\nDescription\n\nFor each treatment observation in the refined model:\n\nFinds the corresponding observation in the original model\nExtracts eligible matches from the refined model\nDetermines their ranks in the original model's full ranking\nReturns matches sorted by their original ranks\n\nThis allows comparison between refined and original matching, showing whether refinement preserves the best matches or introduces changes.\n\nExamples\n\n# Compare refined vs original matches\noriginal_matches = matchinfo(original_model; maxrank = 10)\nrefined_matches = matchinfo(refined_model, original_model; maxrank = 10)\n\n# Check if refinement preserved top matches\nfor (orig_row, ref_row) in zip(eachrow(original_matches), eachrow(refined_matches))\n    if orig_row.treatedunit == ref_row.treatedunit && orig_row.f == ref_row.f\n        original_top3 = orig_row.matchunits[1:min(3, length(orig_row.matchunits))]\n        refined_units = ref_row.matchunits\n        preserved = intersect(original_top3, refined_units)\n        println(\"Unit $(orig_row.treatedunit), F=$(orig_row.f): $(length(preserved))/3 top matches preserved\")\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.matchinfo-Tuple{Union{CIC, CICStratified}}","page":"API Reference","title":"TSCSMethods.matchinfo","text":"matchinfo(model::Union{CIC, CICStratified}; maxrank = 5)\n\nGenerate match information DataFrame for standard CIC models.\n\nPurpose\n\nCreates a detailed summary of matching results showing which control units were matched to each treated observation across all forward periods (F). Provides match unit IDs and their ranking within each time period.\n\nArguments\n\nmodel: Fitted CIC or CICStratified model with completed matching\nmaxrank: Maximum number of top-ranked matches to include per F period (default: 5)\n\nReturns\n\nDataFrame with columns:\n\ntimetreated: Time when treatment occurred\ntreatedunit: ID of the treated unit\nf: Forward period within the outcome window\nmatchunits: Vector of matched control unit IDs (ranked best to worst)\nranks: Vector of rank positions (1 = best match, 2 = second best, etc.)\n\nDescription\n\nFor each treatment observation and each forward period F, this function:\n\nExtracts the top maxrank matched control units\nConverts internal match indices to actual unit IDs\nFilters out periods with no available matches\nReturns results sorted by treatment time and unit ID\n\nThis is useful for:\n\nInspecting match quality and consistency across time periods\nUnderstanding which units serve as controls for specific treatments\nDebugging matching algorithm performance\nCreating match summaries for reporting\n\nExamples\n\n# Get match information with top 3 matches per period\nmatches_df = matchinfo(model; maxrank = 3)\n\n# View matches for a specific treatment\nunit_matches = filter(row -> row.treatedunit == 1001 && row.timetreated == 15, matches_df)\nfor row in eachrow(unit_matches)\n    println(\"F=$(row.f): matched to units $(row.matchunits) with ranks $(row.ranks)\")\nend\n\n# Check if any treatment lacks matches\nno_matches = filter(row -> isempty(row.matchunits), matches_df)\nif !isempty(no_matches)\n    println(\"Warning: Some treatments have no matches\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any, Any, Any}","page":"API Reference","title":"TSCSMethods.meanbalance!","text":"meanbalance!(model, dat, tg, rg)\n\nCalculate the mean balances, for each treated observation from the full set of balances. This will limit the calculations to include those present in model.matches, e.g. in case a caliper has been applied.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any}","page":"API Reference","title":"TSCSMethods.meanbalance!","text":"meanbalance!(model)\n\nCalculate the mean balances, for each treated observation from the full set of balances. This will limit the calculations to include those present in model.matches, e.g. in case a caliper has been applied.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.name_model-Tuple{VeryAbstractCICModel}","page":"API Reference","title":"TSCSMethods.name_model","text":"name_model(model::VeryAbstractCICModel)\n\nGenerate the filename for a set of models.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.observationweights-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.observationweights","text":"treated observation weights\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.obsinfo-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Symbol}}","page":"API Reference","title":"TSCSMethods.obsinfo","text":"obsinfo(\n    match_info_df, data, variables;\n    full_model_observations = nothing,\n    time_column = :t, id_column = :id\n)\n\nExtract covariate information for treated units at their treatment times.\n\nPurpose\n\nGathers covariate values for all treated units at the exact time of their treatment events. For time-varying covariates, this ensures values are captured at the moment of treatment rather than at arbitrary time points. Useful for creating treatment group summaries and balance tables.\n\nArguments\n\nmatch_info_df: DataFrame from matchinfo() containing treatment observations\ndata: Original time-series cross-sectional dataset\nvariables: Vector of column names to extract (e.g., [:population, :gdp, :policy_index])\nfull_model_observations: Optional vector of all treatment observations for comparison (default: nothing)\ntime_column: Name of time variable in data (default: :t)\nid_column: Name of unit identifier in data (default: :id)\n\nReturns\n\nDataFrame with columns:\n\ntimetreated: Time when treatment occurred\ntreatedunit: ID of the treated unit\nremoved: Boolean indicating if observation was removed in refinement (if full_model_observations provided)\nAdditional columns for each variable in variables\n\nDescription\n\nFor each unique treatment observation:\n\nIdentifies the corresponding row in the original data\nExtracts covariate values at the time of treatment\nOptionally compares against full model to identify removed observations\nReturns sorted results with all requested covariate information\n\nThis is essential for:\n\nCreating balance tables showing pre-treatment characteristics\nComparing refined vs full model treatment groups\nUnderstanding treatment group composition\nGenerating summary statistics for reporting\n\nExamples\n\n# Get basic covariate info for treated units\nmatch_df = matchinfo(model)\ncovariates = [:population, :gdp_per_capita, :unemployment_rate]\ntreated_info = obsinfo(match_df, data, covariates; \n                      time_column = :year, id_column = :state_id)\n\n# Compare full vs refined model\nfull_obs = model.observations\nrefined_df = matchinfo(refined_model)\ncomparison = obsinfo(refined_df, data, covariates;\n                    full_model_observations = full_obs,\n                    time_column = :year, id_column = :state_id)\n\n# View removed observations\nremoved_units = filter(row -> row.removed, comparison)\nprintln(\"Removed $(nrow(removed_units)) treatment observations in refinement\")\n\n# Create balance table\nusing Statistics\nfor var in covariates\n    mean_val = mean(skipmissing(treated_info[!, var]))\n    println(\"$(var): mean = $(round(mean_val, digits=3))\")\nend\n\nNotes\n\nUses exact time-unit matching to ensure temporal accuracy\nHandles missing values gracefully through type system\nMaintains sort order for consistent output\nColumn names are parameterized to avoid hardcoded dependencies\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.plot_counterfactual_comparison-Tuple{DataFrames.DataFrame, Symbol}","page":"API Reference","title":"TSCSMethods.plot_counterfactual_comparison","text":"plot_counterfactual_comparison(results_df, outcome_var; kwargs...)\n\nPlot observed vs counterfactual trajectories. Takes DataFrame from preparecounterfactualcomparison_data().\n\nArguments\n\nresults_df: DataFrame with columns f, [outcome_var], counterfactual_trajectory, etc.\noutcome_var: Symbol for outcome variable column name\ntitle: Plot title (default: \"Observed vs Counterfactual Trajectories\")\nxlabel: X-axis label (default: \"Time Period\")\nylabel: Y-axis label (default: string of outcome_var)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.plot_percentage_changes-Tuple{DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.plot_percentage_changes","text":"plot_percentage_changes(results_df; kwargs...)\n\nPlot treatment effects as percentage changes. Takes DataFrame from preparepercentagechange_data().\n\nArguments\n\nresults_df: DataFrame with columns f, pct_change, pct_change_lower, pct_change_upper\ntitle: Plot title (default: \"Treatment Effects (% Change)\")\nxlabel: X-axis label (default: \"Time Period\")\nylabel: Y-axis label (default: \"Percent Change\")  \nmarkersize: Size of scatter points (default: 8)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.prepare_counterfactual_comparison_data-Tuple{TSCSMethods.ImputationResults, Symbol}","page":"API Reference","title":"TSCSMethods.prepare_counterfactual_comparison_data","text":"prepare_counterfactual_comparison_data(imputation_results::ImputationResults, outcome_var::Symbol)\n\nExtract and sort data for observed vs counterfactual trajectory plotting.\n\nThis function prepares the DataFrame needed to visualize the key causal inference comparison: what actually happened (observed) vs. what would have happened without treatment (counterfactual).\n\nArguments\n\nimputation_results::ImputationResults: Output from impute_results()\noutcome_var::Symbol: Column name of the outcome variable (e.g., :Y, :deaths, :GDP)\n\nReturns\n\nDataFrame: Sorted by time period, containing all original columns plus outcome variable. Key columns for plotting:\nf: Time periods\n[outcome_var]: Actual observed outcomes for treated units  \ncounterfactual_trajectory: Estimated counterfactual outcomes\ncounterfactual_lower: Lower bounds of counterfactual confidence intervals\ncounterfactual_upper: Upper bounds of counterfactual confidence intervals\natt: Treatment effects (observed - counterfactual)\n\nExample\n\nimputation = impute_results(model, matches, data, :t, :id)  \nresults_df = prepare_counterfactual_comparison_data(imputation, :Y)\n\n# The key causal story (now just DataFrame columns)\nobserved_trajectory = results_df[!, :Y]                    # What actually happened\ncounterfactual_trajectory = results_df.counterfactual_trajectory  # What would have happened\ntreatment_effect = results_df.att                          # The causal impact\n\nNotes\n\nThe counterfactual trajectory represents the estimated outcome path that treated units would have followed if they had not received treatment, constructed by averaging outcomes from matched control units.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.prepare_percentage_change_data-Tuple{TSCSMethods.ImputationResults}","page":"API Reference","title":"TSCSMethods.prepare_percentage_change_data","text":"prepare_percentage_change_data(imputation_results::ImputationResults)\n\nExtract and sort percentage change data for plotting.\n\nArguments\n\nimputation_results::ImputationResults: Output from impute_results()\n\nReturns\n\nDataFrame: Sorted by time period, containing columns:\nf: Time periods\npct_change: Treatment effects as percentage changes\npct_change_lower: Lower bounds of percentage change confidence intervals  \npct_change_upper: Upper bounds of percentage change confidence intervals\n\nExample\n\nimputation = impute_results(model, matches, data, :t, :id)\nresults_df = prepare_percentage_change_data(imputation)\n\n# Access percentage data (now just DataFrame columns)\npct_effects = results_df.pct_change        # [2.1, 4.2, 1.5, 0.5, ...]\npct_lower = results_df.pct_change_lower    # [0.1, 2.0, -0.5, -1.5, ...]\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.prepare_treatment_effect_data-Tuple{TSCSMethods.ImputationResults}","page":"API Reference","title":"TSCSMethods.prepare_treatment_effect_data","text":"prepare_treatment_effect_data(imputation_results::ImputationResults)\n\nExtract and sort treatment effect data for plotting.\n\nThis function processes ImputationResults to create a clean DataFrame containing treatment effects (ATT) and confidence intervals organized by time period.\n\nArguments\n\nimputation_results::ImputationResults: Output from impute_results()\n\nReturns\n\nDataFrame: Sorted by time period, containing columns:\nf: Time periods  \natt: Average treatment effects for each time period\n2.5%: Lower bounds of 95% confidence intervals  \n97.5%: Upper bounds of 95% confidence intervals\n\nExample\n\nimputation = impute_results(model, matches, data, :t, :id)\nresults_df = prepare_treatment_effect_data(imputation)\n\n# Access the data (now just DataFrame columns)\nplot_times = results_df.f           # [-4, -3, -2, -1, 1, 2, 3, 4, 5]\neffects = results_df.att            # [0.1, 0.2, 0.15, 0.05, 0.3, 0.4, ...]\nlower_ci = results_df[!, Symbol(\"2.5%\")]  # [-0.1, 0.0, -0.05, -0.15, 0.1, ...]\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.processunits-NTuple{9, Any}","page":"API Reference","title":"TSCSMethods.processunits","text":"processunits(matches, observations, outcome, F, ids, reference, t, id, data)\n\nPre-process matched units and outcomes for estimation and bootstrapping.\n\nAlgorithm Overview\n\nThis function transforms the match structure into arrays optimized for ATT estimation:\n\nData Size Calculation: For each treated unit, calculate total data points needed:\nsum(eligible_matches): Total number of matched control units across all F periods\nvalid_outcome_periods_count: Number of F periods with at least one match (treated unit appears once per valid F period)\nTotal = matches + treated unit observations\nMemory Pre-allocation: Create vectors to store:\nWos: Weighted outcomes (positive for treated, negative for matches)\nWrs: Weighted reference period outcomes  \nTus: Treated unit IDs\nMus: Match unit IDs (includes treated unit ID for treated observations)\nFs: F period indicators\nData Population: Use unitstore! to populate arrays with outcome data and weights\n\nMathematical Foundation\n\nFor ATT estimation, we need paired (treated, control) observations for each F period. The weighting scheme is:\n\nTreated unit: weight = +1.0 for outcome, -1.0 for reference\nMatched units: weight = -1/nmatches for outcome, +1/nmatches for reference\n\nArguments\n\nmatches: Vector of match objects with eligible_matches matrices\nobservations: Vector of (time, unit) tuples for treated units\noutcome: Outcome variable symbol\nF: Post-treatment periods for effect estimation\nids: Unit identifier mapping\nreference: Reference period offset (typically negative)\nt, id: Time and unit variable symbols\ndata: Input DataFrame\n\nReturns\n\nTuple of vectors: (Tus, Mus, Wos, Wrs, Fs) where each element contains data for all treated units, structured for efficient estimation.\n\nPerformance Notes\n\nUses threaded allocation and population for scalability\nPre-calculates data sizes to avoid dynamic resizing\nStructured for efficient bootstrapping operations\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.quick_att-Tuple{Any}","page":"API Reference","title":"TSCSMethods.quick_att","text":"quickatt(matchseries;     outcomes = [:deathrte, :case_rte, :deaths, :cases],     F = 10:40,     ttt = false,     tm1 = 30 )\n\nQuickly calculate the att for specified outcomes based on the output of the  matchprocess(). Does not calculate confidence intervals.\n\nCalculates both the individual-level unit effects, and the average effects.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.quick_inspection-Tuple{TSCSMethods.ImputationResults, Symbol}","page":"API Reference","title":"TSCSMethods.quick_inspection","text":"quick_inspection(imputation_results::ImputationResults, outcome_var::Symbol)\n\nQuick inspection function that prints summary statistics and optionally shows plots.\n\nArguments\n\nimputation_results: Output from impute_results()\noutcome_var: Symbol for outcome variable\n\nReturns\n\nSummary statistics printed to console\nBasic diagnostic information about matching quality\n\nExample\n\nimputation = impute_results(model, matches, data, :t, :id)\nquick_inspection(imputation, :Y)\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.refine-Tuple{CIC, Any}","page":"API Reference","title":"TSCSMethods.refine","text":"refine(\n    model::CIC, \n    dat::DataFrame;\n    refinementnum::Int = 5, \n    dobalance::Bool = true,\n    doestimate::Bool = true\n) -> RefinedCIC\n\nRefine a CIC model by keeping only the best refinementnum matches for each treated unit.\n\nArguments\n\nmodel::CIC: A matched CIC model\ndat::DataFrame: Input data containing all model variables\nrefinementnum::Int: Number of best matches to retain per treated unit (default: 5)\ndobalance::Bool: Whether to perform balancing on the refined model (default: true)\ndoestimate::Bool: Whether to perform estimation on the refined model (default: true)\n\nReturns\n\nRefinedCIC: A refined version of the input model with reduced matches\n\nDescription\n\nRefinement improves match quality by keeping only the closest matches for each treated unit, based on the distance metrics computed during the matching stage. This typically improves covariate balance and estimation precision at the cost of statistical power.\n\nExamples\n\n# After matching a model\nmodel = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)\nmatch!(model, data)\n\n# Refine to top 3 matches per treated unit\nrefined_model = refine(model, data; refinementnum = 3)\n\n# Refine without automatic balancing and estimation\nrefined_model = refine(model, data; refinementnum = 5, dobalance = false, doestimate = false)\n\nSee Also\n\ncaliper: Alternative approach using distance thresholds\nmatch!: Initial matching procedure\nbalance!: Balance assessment\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.return_balance_data-Tuple{TSCSMethods.BalanceData, Bool}","page":"API Reference","title":"TSCSMethods.return_balance_data","text":"return_balance_data(balance_data::BalanceData, is_pooled::Bool)\n\nReturn a BalanceData object to the memory pool for reuse, if it came from the pool.\n\nPurpose\n\nCompletes the memory pooling cycle by returning used BalanceData objects back to the pool for future reuse. This prevents memory fragmentation and reduces allocation overhead in subsequent balance calculations.\n\nArguments\n\nbalance_data: The BalanceData object to potentially return to pool\nis_pooled: Whether this object originally came from the pool (from get_balance_data)\n\nDetails\n\nOnly returns objects to pool if they originally came from it (is_pooled == true)\nOnly pools objects with ≤100 elements (larger ones are discarded)\nThread-safe operation using channel-based pools\nShould be called when BalanceData objects are no longer needed\n\nUsage Pattern\n\nbalance_data, is_pooled = get_balance_data(50, true)\n# ... use balance_data for calculations ...\nreturn_balance_data(balance_data, is_pooled)  # Return when done\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.save_inspection_plots","page":"API Reference","title":"TSCSMethods.save_inspection_plots","text":"save_inspection_plots(inspection_results, output_dir::String = \".\", prefix::String = \"analysis\")\n\nSave all plots from inspect_results() to files with publication-quality settings.\n\nArguments\n\ninspection_results: Output from inspect_results()\noutput_dir: Directory to save plots (default: current directory)\nprefix: File prefix for saved plots (default: \"analysis\")\n\nExample\n\n# Run inspection\ninspection = inspect_results(imputation, :Y, plot_percentage_changes=true)\n\n# Save all plots\nsave_inspection_plots(inspection, \"results/\", \"covid_analysis\")\n# Creates: covid_analysis_treatment_effects.png, covid_analysis_counterfactual.png, etc.\n\n\n\n\n\n","category":"function"},{"location":"api/#TSCSMethods.showmatches-Tuple{VeryAbstractCICModel, Tuple{Int64, Int64}}","page":"API Reference","title":"TSCSMethods.showmatches","text":"showmatches(model::VeryAbstractCICModel, treatment_observation::Tuple{Int, Int})\n\nShow ranked matches for a specific treatment observation.\n\nArguments\n\nmodel: Fitted TSCSMethods model  \ntreatment_observation: Tuple of (treatmenttime, unitid)\n\nReturns\n\nVector{Vector{Int}}: Ranked matches for each time period F (sorted best to worst)\n\"Treatment observation not found\": If observation doesn't exist in model\n\nDescription\n\nFor a specific treatment event, shows the ranked list of matched control unit indices for each time period in the post-treatment window F. Units are ranked from best match (rank 1) to worst match based on the matching algorithm's distance calculations and balancing constraints.\n\nThe returned structure is a vector where each element corresponds to a time period F, containing the ranked list of control unit indices (internal to model.matches). To get actual unit IDs, use model.ids[index].\n\nThis function is useful for:\n\nDebugging matching quality for specific treatment events\nUnderstanding which units serve as matches across different time periods\nAssessing match consistency over time\nManual inspection of matching results\n\nExamples\n\n# Show matches for unit 1001 treated at time 15\nmatches = showmatches(model, (15, 1001))\n\nif matches isa String\n    println(matches)  # \"Treatment observation not found\"\nelse\n    println(\"Matches across F periods:\")\n    for (f_idx, f) in enumerate(model.F)\n        period_matches = matches[f_idx]\n        if !isempty(period_matches)\n            # Convert to actual unit IDs\n            match_ids = [model.ids[idx] for idx in period_matches[1:min(3, length(period_matches))]]\n            println(\"F=$f: top 3 matches = $match_ids\")\n        else\n            println(\"F=$f: no matches available\")\n        end\n    end\nend\n\n# Check consistency of top match across periods\nif matches isa Vector && all(length.(matches) .> 0)\n    top_matches = [model.ids[period_matches[1]] for period_matches in matches]\n    println(\"Top match by period: $top_matches\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.stratify-Tuple{Function, CIC, Vararg{Any}}","page":"API Reference","title":"TSCSMethods.stratify","text":"stratify(stratfunc::Function, args...; kwargs...)\n\nApply a stratification function, its arguments, to apply the stratification, calculate the stratified grandbalances, the treated observations in each group, and return the updated model with plot labels.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.stratifyinputs-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.stratifyinputs","text":"    stratifyinputs(X, s, strata)\n\nStratify the output from processunits().\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.treatedinfo-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.treatedinfo","text":"function treatedinfo(\n  model, variables, dat;\n)\n\nGives variable values for treated observations present in the model, for the chosen set of variables. Order is the same as model.observations.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.treatednums!-Tuple{Any}","page":"API Reference","title":"TSCSMethods.treatednums!","text":"assign treatment numbers in each category\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.trim_model-Tuple{Any}","page":"API Reference","title":"TSCSMethods.trim_model","text":"trim_model(model)\n\nRemove treated observations that do not have any valid matches. This copies!\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.unitcounts-Tuple{Any}","page":"API Reference","title":"TSCSMethods.unitcounts","text":"unitcounts(m)\n\ncount the total number of treated and the number of matched units for each F.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.unitstore!-NTuple{13, Any}","page":"API Reference","title":"TSCSMethods.unitstore!","text":"Use the mu matrix to generate vectors of weighted outcomes and unit information, as a preprocessing step for estimation.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.validate_dgp-Tuple{DataFrames.DataFrame, Float64}","page":"API Reference","title":"TSCSMethods.validate_dgp","text":"validate_dgp(data::DataFrame, true_att::Float64)\n\nValidate that the data generating process is working correctly. This is a helper function for debugging DGPs.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.variable_filter-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.variable_filter","text":"variable_filter(\n  model, variable, dat;\n  mn = nothing, mx = nothing\n)\n\nRemove treated observations according to some variable values. The filtered out treated observations will still left as treated in the data, and will not be allowed to be control units for matching.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.variablestrat-Tuple{CIC, Any, Any}","page":"API Reference","title":"TSCSMethods.variablestrat","text":"Generic function to stratify on a covariate present in the dataframe.\n\nAssumes that matching, balancing, and meanbalancing has ocurred.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.whentreated-Tuple{Int64, VeryAbstractCICModel}","page":"API Reference","title":"TSCSMethods.whentreated","text":"whentreated(unit_id::Int, model::VeryAbstractCICModel)\n\nFind when a specific unit received treatment.\n\nArguments\n\nunit_id: ID of the unit to look up  \nmodel: Fitted TSCSMethods model\n\nReturns\n\nVector{Tuple{Int, Int}}: Treatment events for this unit as (treatmenttime, unitid)\n\"Unit not found\": If unit was never treated\n\nDescription\n\nSearches through all treatment observations to find when (if ever) a specific unit received treatment. Returns all treatment events for units that may have multiple treatments over time.\n\nThis function is useful for:\n\nVerifying treatment timing for specific units\nChecking if a unit received treatment multiple times\nDebugging treatment assignment issues\nUnderstanding the treatment history of particular units\n\nExamples\n\n# Check when unit 1001 was treated\ntreatment_events = whentreated(1001, model)\n\nif treatment_events isa String\n    println(\"Unit 1001 was never treated\")\nelse\n    treatment_times = [event[1] for event in treatment_events]\n    println(\"Unit 1001 treated at times: $treatment_times\")\n    \n    if length(treatment_events) > 1\n        println(\"Note: Unit had multiple treatments!\")\n    end\nend\n\n# Check multiple units\nfor unit_id in [1001, 1002, 1003]\n    events = whentreated(unit_id, model)\n    if events isa String\n        println(\"Unit $unit_id: never treated\")\n    else\n        println(\"Unit $unit_id: treated $(length(events)) times\")\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#TSCSMethods.window_distances!-NTuple{13, Any}","page":"API Reference","title":"TSCSMethods.window_distances!","text":"window_distances!(distances, dtots, accums, valideligible_matchescols, validunits, tt, Σinvdict, treated_covariate_rows, lag_times, tg, fmin, Lmin, Lmax; sliding = false)\n\nAssign distance calculations for temporal matching windows.\n\nArguments\n\ndistances: Output matrix to store computed distances\ndtots: Pre-allocated arrays for distance calculations per covariate\naccums: Accumulator arrays for counting valid observations\nvalideligible_matchescols: Valid match columns for each potential match\nvalidunits: Unit identifiers for valid matches\ntt: Treatment time indicator\nΣinvdict: Dictionary of inverse covariance matrices by time period\ntreated_covariate_rows: Treated unit covariate rows over time\nlag_times: Time periods for the treated unit\ntg: Treatment group data structure\nfmin: Minimum relative time offset for matching window\nLmin: Minimum absolute time for matching\nLmax: Maximum absolute time for matching\nsliding: Whether to use sliding windows (default: false, not implemented)\n\nAlgorithm\n\nWindow Definition: Create temporal matching windows based on treatment timing\nDistance Computation: For each valid match and time window:\nExtract control unit data for the same time periods\nCalculate Mahalanobis and covariate-specific distances using alldistances!\nAverage distances over the matching window using average_distances!\nStorage: Store final averaged distances in the distances matrix\n\nMathematical Foundation\n\nImplements the temporal windowing approach from Feltham et al. (2023), where matches are formed based on distance averages over specified pre-treatment periods.\n\nPerformance Notes\n\nComplexity: O(nmatches × windowsize × n_covariates)\nThreading: Called within threaded loops, uses thread-local storage\nMemory: Reuses pre-allocated arrays to minimize allocations\n\nNote\n\nCurrently only supports fixed windows. Sliding window implementation would allow the matching window to vary by treatment time.\n\n\n\n\n\n","category":"method"},{"location":"validation/#Validation-Tests","page":"Validation","title":"Validation Tests","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"This page summarizes the validation suite used to assess statistical correctness, calibration, and robustness of TSCSMethods.jl. The design follows standard practice: gate on inference calibration (coverage, Type I), and report point‑estimate error (bias/MAE/MSE) without universal raw‑error cutoffs.","category":"page"},{"location":"validation/#Randomized-Correctness-(Synthetic)","page":"Validation","title":"Randomized Correctness (Synthetic)","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Files: test/test_synthetic_known_effects.jl, test/simulate_tscs.jl.\nGoal: Recover known per‑f ATT under a randomized, event‑time DGP with adequate support and SNR.\nMethod: Build a model with post window F and pre window L, run match! → estimate!(; dobayesfactor=false), compare ATT to ground truth delta.","category":"page"},{"location":"validation/#Confounded-DGP-—-Bias-Reduction","page":"Validation","title":"Confounded DGP — Bias Reduction","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"File: test/test_confounded_dgp.jl.\nGoal: Show matching/calipers reduce bias when treatment depends on covariates or pre‑trends.\nMethod: Generate confounded data; compare naive event‑time DiD vs TSCSMethods (optionally autobalance).","category":"page"},{"location":"validation/#Coverage-(Null-DGP)","page":"Validation","title":"Coverage (Null DGP)","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Files: test/test_coverage_type1.jl, scripts/sim_bias_coverage.jl.\nGoal: Empirical 95% CI coverage near nominal under ATT = 0.\nGate (script): overall coverage ∈ [0.93, 0.97].","category":"page"},{"location":"validation/#Placebo/Permutation-(Real-Data)","page":"Validation","title":"Placebo/Permutation (Real Data)","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"File: scripts/placebo_permutation.jl.\nGoal: Type I error near 5% on permuted event times in example_data().\nGate: overall Type I ∈ [0.03, 0.07].","category":"page"},{"location":"validation/#Seed-Sweep-(Reporting)","page":"Validation","title":"Seed Sweep (Reporting)","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"File: scripts/seed_sweep.jl.\nGoal: Track MAE/MxE across seeds for a fixed randomized DGP.\nOutput: JSON summary at test/validation/seed_sweep.json (report‑only by default).","category":"page"},{"location":"validation/#How-to-Run","page":"Validation","title":"How to Run","text":"","category":"section"},{"location":"validation/","page":"Validation","title":"Validation","text":"Unit tests: julia --project=. -e 'using Pkg; Pkg.test()'\nSeed sweep (report): julia --project=. scripts/seed_sweep.jl --out test/validation/seed_sweep.json\nCoverage gate: julia --project=. scripts/sim_bias_coverage.jl --seeds 20 --iterations 400 --out test/validation/bias_coverage.json\nPlacebo gate: julia --project=. scripts/placebo_permutation.jl --permutations 200 --iterations 100 --out test/validation/placebo.json","category":"page"},{"location":"validation/","page":"Validation","title":"Validation","text":"For a repository‑level overview of these tests, see VALIDATION_TESTS.md in the project root.","category":"page"},{"location":"#TSCSMethods.jl","page":"Home","title":"TSCSMethods.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Matching methods for causal inference with time-series cross-sectional data","category":"page"},{"location":"","page":"Home","title":"Home","text":"TSCSMethods.jl implements the matching methodology developed in Feltham et al. (2023), which is based on Imai et al. (2021) for causal inference with time-series cross-sectional (TSCS) data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package was initially developed for and used in the analyses of Feltham et al. (2023).","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using TSCSMethods, DataFrames\n\n# Generate example data\ndat = example_data(n_units=50, n_days=60)\n\n# Create model\nmodel = makemodel(\n    dat, :day, :fips, :gub, :death_rte,\n    [:pop_dens], Dict(:pop_dens => false),\n    5:10,    # F: post-treatment periods  \n    -15:-10  # L: pre-treatment periods\n)\n\n# Run complete workflow\nmatch!(model, dat)      # Find matched control units\nbalance!(model, dat)    # Calculate covariate balances  \nestimate!(model, dat)   # Estimate treatment effects\n\n# View results\nmodel.results","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Staggered Treatment Design: Handles units treated at different times\nMatching & Balancing: Find comparable control units and assess covariate balance\nBootstrap Inference: Robust standard errors and confidence intervals\nTime-Series Structure: Explicitly accounts for temporal correlation\nMultiple Outcomes: Support for analyzing multiple dependent variables","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/emfeltham/TSCSMethods.jl\")","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use TSCSMethods.jl in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{feltham_mass_2023,\n  title={Mass gatherings for political expression had no discernible association with the local course of the COVID-19 pandemic in the USA in 2020 and 2021},\n  author={Feltham, Eric and Forastiere, Laura and Alexander, Marcus and Christakis, Nicholas A},\n  journal={Nature Human Behaviour},\n  year={2023},\n  publisher={Nature Publishing Group}\n}\n\n@misc{feltham_tscsmethods_2023,\n  title={TSCSMethods.jl: Matching methods for causal inference with time-series cross-sectional data},\n  author={Feltham, Eric Martin},\n  year={2023},\n  url={https://github.com/emfeltham/TSCSMethods.jl}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please also cite the foundational methodology:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{imai_matching_2021,\n  title={Matching Methods for Causal Inference with Time-Series Cross-Sectional Data},\n  author={Imai, Kosuke and Kim, In Song and Wang, Erik H},\n  journal={American Journal of Political Science},\n  year={2021},\n  publisher={Wiley Online Library}\n}","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Imai, K., Kim, I. S., & Wang, E. H. (2021). Matching Methods for Causal Inference with Time-Series Cross-Sectional Data. American Journal of Political Science.\nFeltham, E., Forastiere, L., Alexander, M., & Christakis, N. A. (2023). Mass gatherings for political expression had no discernible association with the local course of the COVID-19 pandemic in the USA in 2020 and 2021. Nature Human Behaviour.\nKim, I. S., Ruah, A., Wang, E., & Imai, K. (2020). Insongkim/PanelMatch [R, C]. https://github.com/insongkim/PanelMatch (Original work published 2018)","category":"page"},{"location":"methodology/#Methodology","page":"Methodology","title":"Methodology","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"This page explains the statistical methodology implemented in TSCSMethods.jl.","category":"page"},{"location":"methodology/#Overview","page":"Methodology","title":"Overview","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"TSCSMethods.jl implements the extended matching approach for time-series cross-sectional (TSCS) data developed in Feltham et al. (2023), which builds upon and extends the framework of Imai et al. (2021). This method addresses key challenges in causal inference with panel data:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Selection bias: Units self-select into treatment\nTime-varying confounding: Confounders change over time\nTemporal correlation: Outcomes are correlated within units over time","category":"page"},{"location":"methodology/#The-Matching-Framework","page":"Methodology","title":"The Matching Framework","text":"","category":"section"},{"location":"methodology/#Problem-Setup","page":"Methodology","title":"Problem Setup","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Consider panel data with:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Units: i = 1  N (e.g., counties, countries)\nTime periods: t = 1  T\nTreatment: D_it in 0 1 \nOutcome: Y_it\nCovariates: X_it","category":"page"},{"location":"methodology/#Staggered-Treatment-Design","page":"Methodology","title":"Staggered Treatment Design","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"TSCSMethods.jl handles staggered adoption where units receive treatment at different times:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Unit i receives treatment at time tau_i (the specific day of the event)\nD_it = 1\nif t = tau_i, 0 otherwise (treatment occurs only on event day)\nFocus on event studies: effects relative to treatment timing\nSupports any discrete events occurring on specific dates","category":"page"},{"location":"methodology/#Matching-Algorithm","page":"Methodology","title":"Matching Algorithm","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"For each treated unit i at time tau_i:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Define matching window: Pre-treatment periods L = l_1  l_L (negative values)\nFind similar controls: Units j with similar X_jtau_i+l for l in L\nCalculate distances: d(ij) = sum_l in L w_l X_itau_i+l - X_jtau_i+l\nSelect matches: Closest K control units for each treated unit","category":"page"},{"location":"methodology/#Balancing","page":"Methodology","title":"Balancing","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Assess matching quality by comparing covariate distributions:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"textBalance_lk = frac1n_1 sum_i in textTreated X_itau_i+l - frac1n_0 sum_j in textControls X_jtau_i+l","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Good matches have small balance statistics.","category":"page"},{"location":"methodology/#Treatment-Effect-Estimation","page":"Methodology","title":"Treatment Effect Estimation","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Estimate Average Treatment Effect on Treated (ATT) for post-treatment periods f in F:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"hattau_f = frac1textTreated sum_i in textTreated left Y_itau_i+f - frac1M_i sum_j in M_i Y_jtau_i+f right","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"where M_i is the set of matched controls for unit i.","category":"page"},{"location":"methodology/#Crossover-Windows-and-Treatment-History","page":"Methodology","title":"Crossover Windows and Treatment History","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The method incorporates sophisticated treatment history matching:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Crossover window: Period examined for treatment history of potential matches\nPre-treatment crossover: Matches must have similar treatment histories before the focal treatment\nPost-treatment crossover: Control units cannot be treated during specified periods after the focal treatment\nThis prevents contamination from other events that might confound the estimates","category":"page"},{"location":"methodology/#Bootstrap-Inference","page":"Methodology","title":"Bootstrap Inference","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Uncertainty quantification via weighted block-bootstrap:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Block resampling: Resample entire time series of units to account for within-unit temporal dependence\nWeighted procedure: Account for units being used as matches multiple times\nRe-estimation: Calculate ATT for each of 10,000 bootstrap samples\nConfidence intervals: Derived from 2.5th and 97.5th percentiles of bootstrap distribution\nBayes factors: Additional evidence quantification using bootstrap distribution parameters","category":"page"},{"location":"methodology/#Implementation-Details","page":"Methodology","title":"Implementation Details","text":"","category":"section"},{"location":"methodology/#Time-Period-Specification","page":"Methodology","title":"Time Period Specification","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"L periods: Pre-treatment periods for matching (negative values)\nExample: L = -10:-1 uses 10 periods before treatment\nF periods: Post-treatment periods for estimation (positive values)  \nExample: F = 1:5 estimates effects 1-5 periods after treatment\nReference period: Usually -1 (period just before treatment)","category":"page"},{"location":"methodology/#Covariate-Handling","page":"Methodology","title":"Covariate Handling","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Time-invariant: Unit characteristics that don't change over the study period\nDemographics, geography, institutional features\nAny baseline characteristics relevant to the outcome\nTime-varying: Variables that change over time during the matching window\nOutcome history, behavioral indicators, environmental conditions\nAny time-series covariates relevant to treatment assignment and outcomes\nStandardization: Covariates standardized using treated unit variance\nBalance assessment: Standardized mean differences maintained ≤ 0.1","category":"page"},{"location":"methodology/#Distance-Metrics","page":"Methodology","title":"Distance Metrics","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Default uses Mahalanobis distance with temporal averaging:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"d(ij) = frac1L sum_l=1^L sqrt(V_it-l - V_jt-l)^T Sigma_it-l^-1 (V_it-l - V_jt-l)","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"where:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"V_it-l\nis the vector of covariates for unit i at time t-l\nSigma_it-l\nis the diagonal covariance matrix\nL = 30\ndays is the matching window length\nDistance averaged over the pre-treatment period","category":"page"},{"location":"methodology/#Assumptions","page":"Methodology","title":"Assumptions","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The method relies on several key assumptions:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Unconfoundedness: Y_it(0) Y_it(1) perp D_it  X_it textpast\nCommon support: Sufficient overlap in covariate distributions\nNo anticipation: Units don't change behavior before treatment\nSUTVA: No spillover effects between units","category":"page"},{"location":"methodology/#Extensions","page":"Methodology","title":"Extensions","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"TSCSMethods.jl supports several extensions:","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Calipers: Restrict matches to units within distance threshold (balance scores ≤ 0.1)\nStratification: Separate analysis by subgroups (any categorical or binned continuous variables)\nMultiple outcomes: Analyze several dependent variables simultaneously\nRefinement: Iterative improvement of matches (up to 5 best matches per treated unit)\nSpillover effects: Account for geographic spillover (e.g., rally attendees from neighboring counties)\nMultiple treatments: Handle units with repeated treatments over time","category":"page"},{"location":"methodology/#Spillover-Effects-Implementation","page":"Methodology","title":"Spillover Effects Implementation","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"For events with potential geographic spillover (see Feltham et al. 2023 for a detailed case):","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Direct treatment: County hosts the event\nFirst degree: Counties adjacent to event location\nSecond degree: Counties one step away from event location  \nThird degree: Counties two steps away from event location\nSeparate ATT estimation for each exposure level","category":"page"},{"location":"methodology/#References","page":"Methodology","title":"References","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Feltham, E., Forastiere, L., Alexander, M., & Christakis, N. A. (2023). Mass gatherings for political expression had no discernible association with the local course of the COVID-19 pandemic in the USA in 2020 and 2021. Nature Human Behaviour.\nImai, K., Kim, I. S., & Wang, E. H. (2021). Matching Methods for Causal Inference with Time-Series Cross-Sectional Data. American Journal of Political Science.\nRosenbaum, P. R., & Rubin, D. B. (1983). The central role of the propensity score in observational studies for causal effects. Biometrika, 70(1), 41-55.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial walks through a complete analysis using TSCSMethods.jl, explaining each step in detail.","category":"page"},{"location":"tutorial/#Understanding-the-Data-Structure","page":"Tutorial","title":"Understanding the Data Structure","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TSCSMethods expects staggered treatment design data where:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Units (e.g., counties, countries) are treated at specific times\nTreatment is binary (0/1) and occurs on specific dates, not continuously\nTime periods are relative to treatment: negative for pre-treatment, positive for post-treatment","category":"page"},{"location":"tutorial/#Example-Data-Format","page":"Tutorial","title":"Example Data Format","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TSCSMethods, DataFrames\n\n# Generate example data\ndat = example_data(n_units=20, n_days=50, seed=123)\nfirst(dat, 10)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Key columns:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fips: Unit identifier\nday: Time period (0-based)  \ngub: Treatment indicator (1 only on treatment day)\ndeath_rte: Outcome variable\npop_dens: Covariate","category":"page"},{"location":"tutorial/#Step-1:-Model-Creation","page":"Tutorial","title":"Step 1: Model Creation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The makemodel function sets up your causal inference model:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"model = makemodel(\n    dat,              # Your data\n    :day,             # Time variable\n    :fips,            # Unit identifier  \n    :gub,             # Treatment variable\n    :death_rte,       # Outcome variable\n    [:pop_dens],      # Covariates for matching\n    Dict(:pop_dens => false),  # Which covariates are time-varying\n    5:10,             # F: Post-treatment periods to estimate\n    -15:-10           # L: Pre-treatment periods for matching\n)","category":"page"},{"location":"tutorial/#Key-Parameters-Explained","page":"Tutorial","title":"Key Parameters Explained","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"F periods (5:10): How many periods after treatment to estimate effects\nL periods (-15:-10): Which pre-treatment periods to use for matching\nMust be negative for pre-treatment\nUsed to find similar control units\nTime-varying covariates: Set true if covariate changes over time","category":"page"},{"location":"tutorial/#Step-2:-Matching","page":"Tutorial","title":"Step 2: Matching","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Find control units similar to treated units in pre-treatment periods:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"match!(model, dat)\n\n# Check how many matches were found\nprintln(\"Found matches for $(length(model.matches)) treated observations\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The matching algorithm:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Identifies treated units and their treatment times\nFinds control units with similar covariate values in pre-treatment periods\nCreates matched sets for each treated observation","category":"page"},{"location":"tutorial/#Step-3:-Balancing","page":"Tutorial","title":"Step 3: Balancing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Assess how well matching achieved covariate balance:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"balance!(model, dat)\n\n# Check balance results\nmodel.meanbalances","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Good balance means treated and control groups have similar covariate distributions in pre-treatment periods.","category":"page"},{"location":"tutorial/#Step-4:-Estimation","page":"Tutorial","title":"Step 4: Estimation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Estimate average treatment effects with bootstrap inference:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Run estimation (without Bayesian factors for simplicity)\nestimate!(model, dat; dobayesfactor=false)\n\n# View results\nmodel.results","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Results include:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f: Time periods relative to treatment\natt: Average treatment effect estimates\nq025, q975: 95% confidence intervals\ntreated: Number of treated units\nmatches: Number of control units matched","category":"page"},{"location":"tutorial/#Interpreting-Results","page":"Tutorial","title":"Interpreting Results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Look at results\nprintln(\"Treatment Effects by Time Period:\")\nselect(model.results, :f, :att, :q025, :q975)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Positive ATT: Treatment increased the outcome\nNegative ATT: Treatment decreased the outcome  \nConfidence intervals: Statistical uncertainty around estimates\nMultiple time periods: See how effects evolve over time","category":"page"},{"location":"tutorial/#Complete-Example","page":"Tutorial","title":"Complete Example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TSCSMethods, DataFrames\n\n# 1. Load/generate data\ndat = example_data(n_units=30, n_days=60, seed=42)\n\n# 2. Create model  \nmodel = makemodel(dat, :day, :fips, :gub, :death_rte, \n                 [:pop_dens], Dict(:pop_dens => false),\n                 3:8, -20:-10)\n\n# 3. Run complete workflow\nmatch!(model, dat)\nbalance!(model, dat) \nestimate!(model, dat; dobayesfactor=false)\n\n# 4. Examine results\nprintln(\"Number of treated observations: \", model.treatednum)\nprintln(\"Average treatment effect in period 3: \", model.results[1, :att])","category":"page"}]
}
