<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · TSCSMethods.jl</title><meta name="title" content="API Reference · TSCSMethods.jl"/><meta property="og:title" content="API Reference · TSCSMethods.jl"/><meta property="twitter:title" content="API Reference · TSCSMethods.jl"/><meta name="description" content="Documentation for TSCSMethods.jl."/><meta property="og:description" content="Documentation for TSCSMethods.jl."/><meta property="twitter:description" content="Documentation for TSCSMethods.jl."/><meta property="og:url" content="https://human-nature-lab.github.io/TSCSMethods.jl/api/"/><meta property="twitter:url" content="https://human-nature-lab.github.io/TSCSMethods.jl/api/"/><link rel="canonical" href="https://human-nature-lab.github.io/TSCSMethods.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TSCSMethods.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../diagrams/">Visual Guide</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../methodology/">Methodology</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Package-Architecture"><span>Package Architecture</span></a></li><li><a class="tocitem" href="#Complete-Function-and-Type-Reference"><span>Complete Function and Type Reference</span></a></li></ul></li><li><a class="tocitem" href="../validation/">Validation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/human-nature-lab/TSCSMethods.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page provides comprehensive documentation for all TSCSMethods.jl functions and types.</p><h2 id="Package-Architecture"><a class="docs-heading-anchor" href="#Package-Architecture">Package Architecture</a><a id="Package-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Architecture" title="Permalink"></a></h2><p>The following diagram shows the modular architecture of TSCSMethods.jl:</p><p><img src="../assets/images/package_architecture.svg" alt="Package Architecture"/></p><p>The architecture follows a modular design with clear separation of concerns:</p><ul><li><strong>Core System</strong>: Fundamental types and model construction</li><li><strong>Matching System</strong>: Distance-based matching algorithms with sophisticated control unit selection</li><li><strong>Balancing System</strong>: Covariate balance assessment and optimization</li><li><strong>Estimation System</strong>: Treatment effect estimation with bootstrap inference</li><li><strong>Advanced Features</strong>: Specialized methods for complex scenarios</li><li><strong>Utilities</strong>: Data processing, examples, and validation tools</li></ul><h2 id="Complete-Function-and-Type-Reference"><a class="docs-heading-anchor" href="#Complete-Function-and-Type-Reference">Complete Function and Type Reference</a><a id="Complete-Function-and-Type-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Function-and-Type-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.BalanceData" href="#TSCSMethods.BalanceData"><code>TSCSMethods.BalanceData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BalanceData</code></pre><p>Efficient storage for balance computation data with separate arrays for values and missing indicators. This replaces Vector{Union{Missing, Float64}} with better performance and memory pooling capability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/types.jl#L389-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.CIC" href="#TSCSMethods.CIC"><code>TSCSMethods.CIC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CIC &lt;: AbstractCICModel</code></pre><p>Main model type for causal inference with time-series cross-sectional data.</p><p>Contains all information needed for matching, balancing, and estimation in TSCS designs. Created by <code>makemodel()</code> and used throughout the analysis workflow.</p><p><strong>Fields</strong></p><ul><li><code>title::String</code>: Model title for identification</li><li><code>id::Symbol</code>: Column name for unit identifier </li><li><code>t::Symbol</code>: Column name for time variable</li><li><code>outcome::Union{Symbol,Vector{Symbol}}</code>: Outcome variable(s)</li><li><code>treatment::Symbol</code>: Treatment variable (binary 0/1)</li><li><code>covariates::Vector{Symbol}</code>: Covariates used for matching</li><li><code>timevary::Dict{Symbol, Bool}</code>: Whether each covariate is time-varying</li><li><code>reference::Int</code>: Reference time period (default: -1)</li><li><code>F::UnitRange{Int}</code>: Post-treatment periods for estimation</li><li><code>L::UnitRange{Int}</code>: Pre-treatment periods for matching (negative values)</li><li><code>observations::Vector{Tuple{Int, Int}}</code>: Treated observations (time, unit)</li><li><code>ids::Vector{Int}</code>: All unit identifiers</li><li><code>matches::Vector{TreatmentObservationMatches}</code>: Matching results for each treated observation</li><li><code>meanbalances::DataFrame</code>: Covariate balance statistics</li><li><code>grandbalances::Dict</code>: Overall balance measures</li><li><code>iterations::Int</code>: Bootstrap iterations (default: 500)</li><li><code>results::DataFrame</code>: Treatment effect estimates</li><li><code>treatednum::Int</code>: Number of treated observations</li><li><code>estimator::String</code>: Estimator type (default: &quot;ATT&quot;)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using TSCSMethods, DataFrames

data = example_data()
model = makemodel(data, :day, :fips, :gub, :death_rte, 
                 [:pop_dens], Dict(:pop_dens =&gt; false),
                 1:5, -10:-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/types.jl#L65-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.CICStratified" href="#TSCSMethods.CICStratified"><code>TSCSMethods.CICStratified</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CICStratified &lt;: AbstractCICModelStratified</code></pre><p>Stratified model type for causal inference with time-series cross-sectional data.</p><p>Extends the basic CIC model to handle stratified analysis where matching and estimation are performed separately within subgroups defined by a stratifying variable.</p><p><strong>Fields</strong></p><ul><li><code>title::String</code>: Model title for identification</li><li><code>id::Symbol</code>: Column name for unit identifier</li><li><code>t::Symbol</code>: Column name for time variable  </li><li><code>outcome::Union{Symbol,Vector{Symbol}}</code>: Outcome variable(s)</li><li><code>treatment::Symbol</code>: Treatment variable (binary 0/1)</li><li><code>covariates::Vector{Symbol}</code>: Covariates used for matching</li><li><code>timevary::Dict{Symbol, Bool}</code>: Whether each covariate is time-varying</li><li><code>stratifier::Symbol</code>: Variable used for stratification</li><li><code>strata::Vector{Int}</code>: Values of stratifying variable</li><li><code>reference::Int</code>: Reference time period (default: -1)  </li><li><code>F::UnitRange{Int}</code>: Post-treatment periods for estimation</li><li><code>L::UnitRange{Int}</code>: Pre-treatment periods for matching (negative values)</li><li><code>observations::Vector{Tuple{Int, Int}}</code>: Treated observations (time, unit)</li><li><code>ids::Vector{Int}</code>: All unit identifiers</li><li><code>matches::Vector{TreatmentObservationMatches}</code>: Matching results for each treated observation</li><li><code>meanbalances::DataFrame</code>: Covariate balance statistics by stratum</li><li><code>grandbalances::Dict</code>: Overall balance measures by stratum</li><li><code>iterations::Int</code>: Bootstrap iterations (default: 500)</li><li><code>results::DataFrame</code>: Treatment effect estimates by stratum</li><li><code>treatednum::Dict{Int64, Int64}</code>: Number of treated observations per stratum</li><li><code>estimator::String</code>: Estimator type (default: &quot;ATT&quot;)</li><li><code>labels::Dict{Int64, String}</code>: Human-readable labels for strata</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create stratified model
model = makemodel(data, :day, :fips, :gub, :death_rte,
                 [:pop_dens], Dict(:pop_dens =&gt; false),
                 1:5, -10:-1)
strat_model = stratify(model, data, :region)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/types.jl#L127-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.Fblock" href="#TSCSMethods.Fblock"><code>TSCSMethods.Fblock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    Fblock</code></pre><p>Holds the relevant information for bootstrapping and estimation, for a specific f in the outcome window (an f in a stratum when the model is stratified).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/types.jl#L374-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.ImputationResults" href="#TSCSMethods.ImputationResults"><code>TSCSMethods.ImputationResults</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImputationResults</code></pre><p>Container for counterfactual imputation results.</p><p><strong>Fields</strong></p><ul><li><code>results</code>: DataFrame with counterfactual trajectories and treatment effects</li><li><code>matched_pretreatment_avg</code>: Average pre-treatment outcome for matched controls</li><li><code>treated_pretreatment_avg</code>: Average pre-treatment outcome for treated units</li><li><code>baseline_difference</code>: Difference in pre-treatment averages (treated - matched)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/imputation.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.TreatmentObservationCaliperMatches" href="#TSCSMethods.TreatmentObservationCaliperMatches"><code>TSCSMethods.TreatmentObservationCaliperMatches</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TreatmentObservationCaliperMatches</code></pre><p>Stores matching results for caliper-constrained CIC models.</p><p>Similar to TreatmentObservationMatches but for models where matches are restricted by caliper constraints (maximum allowable distance thresholds).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/types.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.TreatmentObservationMatches" href="#TSCSMethods.TreatmentObservationMatches"><code>TSCSMethods.TreatmentObservationMatches</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TreatmentObservationMatches</code></pre><p>Stores matching results for each treated observation in basic CIC models.</p><p>Contains the core data structures for matching:</p><ul><li><code>eligible_matches</code>: Boolean matrix indicating which control units are eligible matches</li><li><code>distances</code>: Computed distances between treated and control units  </li><li><code>match_rankings</code>: Ranked preferences for matches by time period</li></ul><p>This is the fundamental data structure for storing match relationships in TSCS designs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/types.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.TreatmentObservationRefinedMatches" href="#TSCSMethods.TreatmentObservationRefinedMatches"><code>TSCSMethods.TreatmentObservationRefinedMatches</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TreatmentObservationRefinedMatches</code></pre><p>Stores matching results for refined CIC models.</p><p>Used in refined matching procedures where the initial match set is  iteratively improved through additional matching criteria.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/types.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.__fill_meanbalances!-NTuple{5, Any}" href="#TSCSMethods.__fill_meanbalances!-NTuple{5, Any}"><code>TSCSMethods.__fill_meanbalances!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">__fill_meanbalances!(balance_row, periods_with_matches, lag_periods_count, covariates, timevary)</code></pre><p>Allocate BalanceData objects for a single treated observation with error handling and memory pooling.</p><p><strong>Purpose</strong></p><p>Handles the actual allocation of BalanceData objects for one row of the meanbalances DataFrame. Implements error-safe memory pooling with proper cleanup if allocation fails partway through.</p><p><strong>Arguments</strong></p><ul><li><code>balance_row</code>: Single row from meanbalances DataFrame to populate</li><li><code>periods_with_matches</code>: Number of forward periods that have eligible matches</li><li><code>lag_periods_count</code>: Number of lag periods (for time-varying covariate sizing)</li><li><code>covariates</code>: Vector of covariate names to allocate storage for</li><li><code>timevary</code>: Dict indicating which covariates are time-varying</li></ul><p><strong>Details</strong></p><ul><li>For time-varying covariates: Creates Vector{BalanceData} with <code>periods_with_matches</code> elements, each of size <code>lag_periods_count</code></li><li>For static covariates: Creates single BalanceData of size <code>periods_with_matches</code></li><li>Uses memory pooling via <code>get_balance_data()</code> for allocation efficiency</li><li>Implements error handling: if allocation fails, returns all pooled objects to prevent memory leaks</li><li>Tracks all pooled allocations for proper cleanup</li></ul><p><strong>Error Handling</strong></p><p>If any allocation fails, all previously allocated pooled objects are automatically returned to their respective pools to prevent memory leaks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing_utilities.jl#L293-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._calculate_counterfactuals!-NTuple{4, Any}" href="#TSCSMethods._calculate_counterfactuals!-NTuple{4, Any}"><code>TSCSMethods._calculate_counterfactuals!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_calculate_counterfactuals!(matches_with_treatment, outcome_lookup, outcome_var, tvar)</code></pre><p>Calculate observed outcomes and counterfactual values for each matched observation. Modifies matches<em>with</em>treatment in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/imputation.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._calculate_pretreatment_averages-Tuple{Any, Any, Any}" href="#TSCSMethods._calculate_pretreatment_averages-Tuple{Any, Any, Any}"><code>TSCSMethods._calculate_pretreatment_averages</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_calculate_pretreatment_averages(matches_with_treatment, outcome_lookup, outcome_var)</code></pre><p>Calculate pre-treatment outcome averages for treated and matched units. Returns (matched<em>avg, treated</em>avg).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/imputation.jl#L161-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._estimate!-Tuple{Any, Any, Any, Vector{Symbol}, Vararg{Any, 8}}" href="#TSCSMethods._estimate!-Tuple{Any, Any, Any, Vector{Symbol}, Vararg{Any, 8}}"><code>TSCSMethods._estimate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>version for multiple outcomes</p><p>does not include p-values, bayesfactor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._fast_quantiles-Tuple{Vector{Float64}, Vector{Float64}}" href="#TSCSMethods._fast_quantiles-Tuple{Vector{Float64}, Vector{Float64}}"><code>TSCSMethods._fast_quantiles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Fast quantile computation from pre-sorted data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_utilities.jl#L112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._fill_meanbalances!-NTuple{6, Any}" href="#TSCSMethods._fill_meanbalances!-NTuple{6, Any}"><code>TSCSMethods._fill_meanbalances!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_fill_meanbalances!(meanbalances, matches, lag_periods_count, covariates, timevary, forward_periods_count)</code></pre><p>Populate meanbalances DataFrame with properly sized BalanceData objects for each treated observation.</p><p><strong>Purpose</strong></p><p>For each treated observation, determines which forward periods (F values) have at least one eligible match, then allocates appropriate BalanceData storage structures. The allocation pattern depends on whether covariates are time-varying or static.</p><p><strong>Arguments</strong></p><ul><li><code>meanbalances</code>: DataFrame to populate (one row per treated observation)</li><li><code>matches</code>: Vector of match objects containing eligible_matches matrices</li><li><code>lag_periods_count</code>: Number of lag periods (length of L range)</li><li><code>covariates</code>: Vector of covariate names</li><li><code>timevary</code>: Dict indicating which covariates are time-varying</li><li><code>forward_periods_count</code>: Number of forward periods (length of F range)</li></ul><p><strong>Details</strong></p><ul><li>Creates <code>:fs</code> column indicating which forward periods have matches</li><li>For time-varying covariates: Vector{BalanceData} of length periods<em>with</em>matches</li><li>For static covariates: Single BalanceData of length periods<em>with</em>matches</li><li>Uses memory pooling via <code>get_balance_data()</code> for efficiency</li><li>Each BalanceData object sized according to lag<em>periods</em>count for time-varying covariates</li></ul><p><strong>Storage Structure</strong></p><pre><code class="nohighlight hljs">meanbalances[i, :covariate] = 
  - Time-varying: [BalanceData(lag_periods), BalanceData(lag_periods), ...]
  - Static: BalanceData(periods_with_matches)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing_utilities.jl#L243-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._makegroupindices-NTuple{11, Any}" href="#TSCSMethods._makegroupindices-NTuple{11, Any}"><code>TSCSMethods._makegroupindices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_makegroupindices(tidx, ridx, tridx, tts, uid, fmax, Lmin, tvec, idvec, treatvecbool, X)</code></pre><p>Core implementation for building group indices without exposure data.</p><p><strong>Purpose</strong></p><p>Populates the index dictionaries by creating SubArray views for each (treatment_time, unit) combination. Uses parallel processing to efficiently handle large datasets.</p><p><strong>Arguments</strong></p><ul><li><code>tidx</code>, <code>ridx</code>, <code>tridx</code>: Pre-allocated dictionaries to populate</li><li><code>tts</code>: Vector of treatment times (when treatments occurred)  </li><li><code>uid</code>: Vector of unique unit IDs</li><li><code>fmax</code>, <code>Lmin</code>: Time window bounds</li><li><code>tvec</code>, <code>idvec</code>, <code>treatvecbool</code>: Original data vectors</li><li><code>X</code>: Covariate data matrix</li></ul><p><strong>Implementation Details</strong></p><ul><li>Uses <code>Threads.@threads :greedy</code> for parallel processing across (treatment_time, unit) pairs</li><li>For each pair, calls <code>getyes!()</code> to determine which data rows fall within the time window</li><li>Creates SubArray views using <code>@views</code> macro for memory efficiency</li><li>Thread-safe due to non-overlapping dictionary key assignments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/groupindices.jl#L139-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._makegroupindices-NTuple{13, Any}" href="#TSCSMethods._makegroupindices-NTuple{13, Any}"><code>TSCSMethods._makegroupindices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_makegroupindices(tidx, ridx, tridx, tts, uid, fmax, Lmin, tvec, idvec, treatvecbool, X, exidx, exvec)</code></pre><p>Core implementation for building group indices with exposure data support.</p><p><strong>Purpose</strong></p><p>Extended version that additionally creates indexed views of exposure data alongside the standard covariate, time, and treatment indices. Used for exposure-based matching where treatment assignment depends on external exposure variables.</p><p><strong>Arguments</strong></p><ul><li><code>tidx</code>, <code>ridx</code>, <code>tridx</code>: Standard index dictionaries to populate</li><li><code>exidx</code>: Additional dictionary for exposure data views</li><li><code>exvec</code>: Exposure data vector</li><li>Other arguments same as standard version</li></ul><p><strong>Details</strong></p><p>Identical logic to the standard version but additionally populates <code>exidx[(tt, unit)]</code> with SubArray views of the exposure data for each (treatment_time, unit) combination. This enables efficient access to exposure histories during matching algorithms that consider exposure patterns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/groupindices.jl#L184-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._validate_distaveraging_inputs-NTuple{4, Any}" href="#TSCSMethods._validate_distaveraging_inputs-NTuple{4, Any}"><code>TSCSMethods._validate_distaveraging_inputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_validate_distaveraging_inputs(dtots, lag_times, fw, accums) -&gt; Int</code></pre><p>Validate common inputs for distance averaging functions.</p><p><strong>Returns</strong></p><ul><li><code>n_times::Int</code>: Number of time points after validation</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: For empty required inputs</li><li><code>DimensionMismatch</code>: For inconsistent array dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing_utilities.jl#L167-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods._validate_imputation_inputs-NTuple{6, Any}" href="#TSCSMethods._validate_imputation_inputs-NTuple{6, Any}"><code>TSCSMethods._validate_imputation_inputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_validate_imputation_inputs(m, matches, dat, tvar, unit_var, stratum)</code></pre><p>Validate inputs for imputation function. Throws ArgumentError if validation fails.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/imputation.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.alldistances!-NTuple{5, Any}" href="#TSCSMethods.alldistances!-NTuple{5, Any}"><code>TSCSMethods.alldistances!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alldistances!(dtotals, Σinvdict, xrows, yrows, lag_times)</code></pre><p>Calculate Mahalanobis and individual covariate distances for time-series matching.</p><p><strong>Mathematical Foundation</strong></p><p>This function implements the core distance calculations for the Feltham et al. (2023)  extension of Imai et al. (2021) matching methodology:</p><p><strong>Mahalanobis Distance</strong></p><p>For each time point τ, calculates:</p><pre><code class="nohighlight hljs">d_M(x_τ, y_τ) = √[(x_τ - y_τ)ᵀ Σ_τ⁻¹ (x_τ - y_τ)]</code></pre><p>where:</p><ul><li>x<em>τ, y</em>τ are covariate vectors for treated and control units at time τ</li><li>Σ_τ⁻¹ is the inverse covariance matrix for time τ (from all units)</li></ul><p><strong>Individual Covariate Distances (for Calipers)</strong></p><p>For each covariate j:</p><pre><code class="nohighlight hljs">d_j(x_jτ, y_jτ) = √[(x_jτ - y_jτ)² / σ²_jτ]</code></pre><p>where σ²<em>jτ = Σ</em>τ[j,j] is the variance of covariate j at time τ.</p><p><strong>Algorithm</strong></p><ol><li><strong>Matrix Caching</strong>: Pre-cache all covariance matrices for lag_times to eliminate  repeated hash lookups (Performance optimization - maintains exact results)</li><li><strong>Distance Calculation</strong>: For each time point, compute both Mahalanobis and  individual distances simultaneously</li><li><strong>Missing Data</strong>: If any covariate is missing, the corresponding distance is <code>missing</code></li></ol><p><strong>Arguments</strong></p><ul><li><code>dtotals</code>: Pre-allocated output arrays [Mahalanobis, Cov1, Cov2, ...] </li><li><code>Σinvdict</code>: Dictionary mapping time → inverse covariance matrix</li><li><code>xrows</code>: Treated unit covariate vectors over time</li><li><code>yrows</code>: Control unit covariate vectors over time  </li><li><code>lag_times</code>: Time points for distance calculation</li></ul><p><strong>Performance Notes</strong></p><ul><li><strong>Optimization</strong>: Caches covariance matrices to avoid O(m) hash lookups per distance</li><li><strong>Complexity</strong>: O(k) where k = length(lag_times), down from O(k×m) with m unique times</li><li><strong>Memory</strong>: Uses views and pre-allocated arrays for efficiency</li></ul><p><strong>Statistical Accuracy</strong></p><p>This function preserves exact mathematical equivalence to the original algorithm while providing significant performance improvements through caching.</p><p><strong>References</strong></p><ul><li>Feltham et al. (2023): Mass gatherings methodology with extended time windows</li><li>Imai et al. (2021): Original matching framework for TSCS data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing.jl#L467-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.att!-Tuple{Any, Any, Any}" href="#TSCSMethods.att!-Tuple{Any, Any, Any}"><code>TSCSMethods.att!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    att!(atts, tcounts, fblocks)</code></pre><p>Calculate the att for each f, for a the set of treated units and matches contained in the fblocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_utilities.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.autobalance-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}" href="#TSCSMethods.autobalance-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}"><code>TSCSMethods.autobalance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">autobalance(
  model, dat;
  refinementnum = 5,
  calmin = 0.08, step = 0.05,
  initial_bals = nothing
)</code></pre><p>Automatically balance via a simple algorithm. Start with initial caliper of 1.0, and subtract <code>step</code> whenever the grand mean balance threshold (0.1) is not met.</p><p>initial_bals is specified, work downward from the initial specified caliper for one or more selected variables. Unspecified variables start at a caliper of 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/autobalancing.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.average_distances!-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}, Any, Any, Any}} where T" href="#TSCSMethods.average_distances!-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}, Any, Any, Any}} where T"><code>TSCSMethods.average_distances!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">average_distances!(drow, dtots, accums, lag_times, fw) where {T}</code></pre><p>Calculate averaged distances over time windows for fixed window matching.</p><p><strong>Mathematical Formula</strong></p><p>For each distance type k and valid time window W:</p><pre><code class="nohighlight hljs">drow[k] = (1/|W|) ∑_{τ ∈ W} dtots[k][l] where lag_times[l] = τ  </code></pre><p>This is the fixed-window version of distance averaging, used when matching windows are constant rather than sliding.</p><p><strong>Arguments</strong></p><ul><li><code>drow</code>: Output vector [K] where K = number of distance types</li><li><code>dtots</code>: Input distances [K][T] for K distance types over T time points</li><li><code>accums</code>: Working array for counting valid observations per distance type  </li><li><code>lag_times</code>: Time points corresponding to dtots columns</li><li><code>fw</code>: Fixed matching window specification</li></ul><p><strong>Differences from Sliding Version</strong></p><ul><li><strong>Output</strong>: Single vector instead of matrix (no outcome<em>period</em>index, m indices)</li><li><strong>Use Case</strong>: Fixed matching windows vs. sliding windows</li><li><strong>Performance</strong>: Slightly more efficient due to simpler indexing</li></ul><p><strong>Algorithm</strong></p><p>Identical to sliding window version but with simplified output structure:</p><ol><li>Pre-compute window bounds for efficiency</li><li>Type-stable initialization based on data type T</li><li>Accumulate valid distances within window</li><li>Average by count of valid observations</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing_utilities.jl#L349-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.average_distances!-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}, Vararg{Any, 5}}} where T" href="#TSCSMethods.average_distances!-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}, Vararg{Any, 5}}} where T"><code>TSCSMethods.average_distances!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">average_distances!(distances, dtots, accums, lag_times, fw, outcome_period_index, m) where {T}</code></pre><p>Calculate averaged distances over time windows for sliding window matching.</p><p><strong>Mathematical Formula</strong></p><p>For each distance type k and valid time window W:</p><pre><code class="nohighlight hljs">distances[k][outcome_period_index, m] = (1/|W|) ∑_{τ ∈ W} dtots[k][l] where lag_times[l] = τ</code></pre><p><strong>Arguments</strong></p><ul><li><code>distances</code>: Output array [K][outcome<em>period</em>index, m] where K = number of distance types</li><li><code>dtots</code>: Input distances [K][T] for K distance types over T time points  </li><li><code>accums</code>: Working array for counting valid observations per distance type</li><li><code>lag_times</code>: Time points corresponding to dtots columns</li><li><code>fw</code>: Matching window specification (e.g., -10:-1 for 10 periods before)</li><li><code>outcome_period_index</code>: Window index (for sliding windows)</li><li><code>m</code>: Match index</li></ul><p><strong>Algorithm</strong></p><ol><li><strong>Window Bounds</strong>: Pre-compute fw<em>min, fw</em>max = extrema(fw) once</li><li><strong>Type-Based Init</strong>: Initialize based on data type T for type stability</li><li><strong>Filtered Iteration</strong>: Only process lag<em>times[l] where fw</em>min ≤ lag<em>times[l] ≤ fw</em>max</li><li><strong>Missing Handling</strong>: Skip missing values, track counts in accums</li><li><strong>Averaging</strong>: Divide accumulated sums by valid observation counts</li></ol><p><strong>Performance</strong></p><ul><li><strong>Complexity</strong>: O(|lag<em>times|) with early termination when lag</em>times[l] &gt; fw_max  </li><li><strong>Memory</strong>: Uses pre-allocated arrays, no intermediate allocations</li><li><strong>Type Stability</strong>: Compile-time specialization for Float64 vs Union types</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing_utilities.jl#L226-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.balance!-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}" href="#TSCSMethods.balance!-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}"><code>TSCSMethods.balance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">balance!(model::VeryAbstractCICModel, dat::DataFrame) -&gt; VeryAbstractCICModel</code></pre><p>Perform covariate balancing on a matched model to ensure treated and control units are comparable on observed characteristics.</p><p><strong>Arguments</strong></p><ul><li><code>model::VeryAbstractCICModel</code>: A CIC model that has been matched (using <code>match!</code>)</li><li><code>dat::DataFrame</code>: Input data containing all model variables</li></ul><p><strong>Returns</strong></p><ul><li>The input model with updated balance statistics</li></ul><p><strong>Description</strong></p><p>This function performs two types of balancing:</p><ol><li>Mean balancing: Computes balance statistics for each covariate across treatment periods</li><li>Grand balancing: Aggregates balance statistics across the entire model</li></ol><p>Balancing assesses how well the matching procedure achieved covariate balance between treated and control groups. Poor balance may indicate the need for refinement via calipers or other restrictions.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input data is empty</li><li><code>ErrorException</code>: If balance calculations fail</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># After constructing and matching a model
model = makemodel(data, :time, :id, :treatment, :outcome, 
                 [:covar1, :covar2], timevary_dict, F_periods, L_periods)
match!(model, data)

# Perform balancing
balance!(model, data)

# Check balance results
checkbalances(model, data)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#TSCSMethods.checkbalances-Tuple{AbstractCICModel}"><code>checkbalances</code></a>: Assess balance quality</li><li><a href="#TSCSMethods.autobalance-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}"><code>autobalance</code></a>: Automatic balance improvement</li><li><a href="#TSCSMethods.match!-Tuple{AbstractCICModel, DataFrames.DataFrame}"><code>match!</code></a>: Matching procedure that should precede balancing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing.jl#L3-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.bootinfo!-Tuple{Any, Any, Any}" href="#TSCSMethods.bootinfo!-Tuple{Any, Any, Any}"><code>TSCSMethods.bootinfo!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bootinfo!(res, oc, boots; qtiles = [0.025, 0.5, 0.975])</code></pre><p>Format the bootstrap matrix into the results dataframe. Assumes that att() has already been added to res.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_utilities.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.bootinfo!-Tuple{Any, Any}" href="#TSCSMethods.bootinfo!-Tuple{Any, Any}"><code>TSCSMethods.bootinfo!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bootinfo!(res, boots; qtiles = [0.025, 0.5, 0.975])</code></pre><p>Format the bootstrap matrix into the results dataframe. Assumes that att() has already been added to res.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_utilities.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.bootstrap!-NTuple{6, Any}" href="#TSCSMethods.bootstrap!-NTuple{6, Any}"><code>TSCSMethods.bootstrap!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    bootstrap!(boots, tcountmat, fblocks, ids, treatdex, iterations)</code></pre><p>Perform bootstrapping of the att for each f in the outcome window. Does so for the given set of treated units and matches contained in the fblocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/bootstrapping.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.calculate_overall_summary-Tuple{TSCSMethods.ImputationResults, Symbol}" href="#TSCSMethods.calculate_overall_summary-Tuple{TSCSMethods.ImputationResults, Symbol}"><code>TSCSMethods.calculate_overall_summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_overall_summary(imputation_results::ImputationResults, outcome_var::Symbol)</code></pre><p>Calculate overall treatment effect summary statistics and balance diagnostics.</p><p>This function computes key summary statistics that help assess the quality and magnitude of the causal inference results.</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results::ImputationResults</code>: Output from <code>impute_results()</code></li><li><code>outcome_var::Symbol</code>: Column name of the outcome variable</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Summary statistics with fields:<ul><li><code>treated_observed_mean</code>: Average observed outcome for treated units</li><li><code>overall_att</code>: Overall average treatment effect</li><li><code>counterfactual_mean</code>: Average counterfactual outcome </li><li><code>baseline_difference</code>: Pre-treatment difference between treated and matched units</li><li><code>treated_pretreatment_avg</code>: Pre-treatment average for treated units</li><li><code>matched_pretreatment_avg</code>: Pre-treatment average for matched controls</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">imputation = impute_results(model, matches, data, :t, :id)
summary = calculate_overall_summary(imputation, :Y)

# Key statistics
println(&quot;Overall ATT: &quot;, summary.overall_att)
println(&quot;Baseline balance: &quot;, summary.baseline_difference)  # Should be close to 0
println(&quot;Treatment magnitude: &quot;, summary.overall_att / summary.treated_observed_mean * 100, &quot;%&quot;)</code></pre><p><strong>Notes</strong></p><ul><li><code>baseline_difference</code> close to 0 indicates good matching quality</li><li><code>overall_att</code> is the main causal estimate  </li><li>Comparing pre-treatment averages helps assess whether matching achieved balance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L182-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.calculate_sample_Σs!-Tuple{Any, Any, Any, Any, Bool}" href="#TSCSMethods.calculate_sample_Σs!-Tuple{Any, Any, Any, Any, Bool}"><code>TSCSMethods.calculate_sample_Σs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>inverted covariance matrix for mahalanobis distance (all units at t)</p><p>inverted sqrt(vars) for balance score calculations (treated units at t)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing_utilities.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.caliper-Tuple{CIC, Any, Any}" href="#TSCSMethods.caliper-Tuple{CIC, Any, Any}"><code>TSCSMethods.caliper</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">caliper(
    model::CIC, 
    acaliper::Dict{Symbol, Float64}, 
    dat::DataFrame; 
    dobalance::Bool = true
) -&gt; CaliperCIC</code></pre><p>Apply caliper restrictions to a CIC model by excluding matches beyond specified distance thresholds.</p><p><strong>Arguments</strong></p><ul><li><code>model::CIC</code>: A matched CIC model</li><li><code>acaliper::Dict{Symbol, Float64}</code>: Dictionary mapping covariates to maximum allowed distances</li><li><code>dat::DataFrame</code>: Input data containing all model variables</li><li><code>dobalance::Bool</code>: Whether to perform balancing on the calipered model (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>CaliperCIC</code>: A calipered version of the input model with restricted matches</li></ul><p><strong>Description</strong></p><p>Caliper restrictions improve match quality by excluding matches where the distance on specified covariates exceeds the given thresholds. This helps ensure that matched units are similar on the most important dimensions, potentially improving balance and reducing bias.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># After matching a model
model = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)
match!(model, data)

# Apply calipers - exclude matches with distance &gt; 0.25 on covar1 or &gt; 0.5 on covar2
caliper_specs = Dict(:covar1 =&gt; 0.25, :covar2 =&gt; 0.5)
calipered_model = caliper(model, caliper_specs, data)

# Apply calipers without automatic balancing
calipered_model = caliper(model, caliper_specs, data; dobalance = false)</code></pre><p><strong>Notes</strong></p><ul><li>Stricter calipers improve match quality but reduce the number of matches</li><li>Use <a href="#TSCSMethods.autobalance-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}"><code>autobalance</code></a> to automatically determine appropriate caliper values</li></ul><p><strong>See Also</strong></p><ul><li><a href="#TSCSMethods.refine-Tuple{CIC, Any}"><code>refine</code></a>: Alternative approach using match ranking</li><li><a href="#TSCSMethods.autobalance-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}"><code>autobalance</code></a>: Automatic caliper selection</li><li><a href="#TSCSMethods.match!-Tuple{AbstractCICModel, DataFrames.DataFrame}"><code>match!</code></a>: Initial matching procedure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/caliper.jl#L5-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.change_pct-Tuple{Any, Any}" href="#TSCSMethods.change_pct-Tuple{Any, Any}"><code>TSCSMethods.change_pct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change_pct(val, attval)</code></pre><p>Calculate percentage change from baseline value.</p><p><strong>Arguments</strong></p><ul><li><code>val</code>: Baseline value</li><li><code>attval</code>: Treatment effect (difference from baseline)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Percentage change (100 * attval / val)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">baseline = 100.0
treatment_effect = 10.0
pct_change = change_pct(baseline, treatment_effect)  # Returns 10.0 (10% increase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L715-L733">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.checkbalances-Tuple{AbstractCICModel}" href="#TSCSMethods.checkbalances-Tuple{AbstractCICModel}"><code>TSCSMethods.checkbalances</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkbalances(
  m::Dict{Symbol, Union{Float64, Vector{Float64}}};
  threshold = 0.1, stratareduce = true
)</code></pre><p>Simply check whether the grand means are above the std. balance threshold. Returns a Bool for each covariate. If Stratareduce is true, then the strata balances will be agggregated to the covariate level, such that a violation in any caliper triggers a violation in the aggregated output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/autobalancing.jl#L156-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.checksample-Tuple{Any, Any}" href="#TSCSMethods.checksample-Tuple{Any, Any}"><code>TSCSMethods.checksample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>not stratified</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/resampling.jl#L105-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.combostrat-Tuple{Any, Vector{Symbol}, Any}" href="#TSCSMethods.combostrat-Tuple{Any, Vector{Symbol}, Any}"><code>TSCSMethods.combostrat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combostrat(model, dat, vars::Vector{Symbol}; varslabs = nothing)</code></pre><p>Stratify based on the combinations of one or more variables that exist in the data. Strata are formed directly from the variable values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/stratification.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.compare_strata-Tuple{Vector, Symbol, Vector{String}}" href="#TSCSMethods.compare_strata-Tuple{Vector, Symbol, Vector{String}}"><code>TSCSMethods.compare_strata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_strata(imputation_results_list::Vector, outcome_var::Symbol, stratum_names::Vector{String})</code></pre><p>Compare results across multiple strata or model specifications.</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results_list</code>: Vector of ImputationResults from different strata</li><li><code>outcome_var</code>: Symbol for outcome variable</li><li><code>stratum_names</code>: Names for each stratum for labeling</li></ul><p><strong>Returns</strong></p><ul><li>Comparison plot showing ATT estimates across strata</li><li>Summary table of key statistics</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Run analysis for each stratum
imputation1 = impute_results(model, matches, data, :t, :id, stratum=1)
imputation2 = impute_results(model, matches, data, :t, :id, stratum=2)

# Compare results
comparison = compare_strata([imputation1, imputation2], :Y, [&quot;Urban&quot;, &quot;Rural&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L631-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.compute_treated_std-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}" href="#TSCSMethods.compute_treated_std-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}"><code>TSCSMethods.compute_treated_std</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_treated_std(model::VeryAbstractCICModel, dat::DataFrame) -&gt; Dict{Tuple{Int64, Symbol}, Float64}</code></pre><p>Compute standardization factors (1/σ) for covariates across all treated units&#39; matching periods.</p><p><strong>Purpose</strong></p><p>For balance calculations, we need to standardize covariate differences by the standard deviation of treated units during their matching windows. This ensures balance statistics are comparable across covariates with different scales.</p><p><strong>Returns</strong></p><p>Dictionary with keys <code>(time_offset, covariate)</code> and values <code>1/σ</code>, where:</p><ul><li><code>time_offset</code>: Days relative to treatment (negative = pre-treatment, positive = post-treatment)  </li><li><code>covariate</code>: Covariate name</li><li><code>1/σ</code>: Inverse standard deviation for standardization</li></ul><p><strong>Details</strong></p><p>For each treated unit at treatment time <code>t</code>, we collect covariate values from their matching window <code>[t + min(L), t + max(F)]</code>. We then compute the standard deviation of each covariate at each time offset across all treated units and return the inverse for efficient multiplication during balance calculations.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">std_factors = compute_treated_std(model, data)
# std_factors[(-10, :population)] = 0.05  # 1/σ for population 10 days before treatment</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing_utilities.jl#L112-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.countmemb-Tuple{Any, Int64}" href="#TSCSMethods.countmemb-Tuple{Any, Int64}"><code>TSCSMethods.countmemb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>faster version of countmap, use when length is known</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/resampling.jl#L33-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.create_inspection_dashboard-Tuple{TSCSMethods.ImputationResults, Symbol}" href="#TSCSMethods.create_inspection_dashboard-Tuple{TSCSMethods.ImputationResults, Symbol}"><code>TSCSMethods.create_inspection_dashboard</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_inspection_dashboard(imputation_results::ImputationResults, outcome_var::Symbol)</code></pre><p>Create a comprehensive dashboard with all inspection plots in a single figure.</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results</code>: ImputationResults struct from impute_results()</li><li><code>outcome_var</code>: Symbol representing the outcome variable column name</li></ul><p><strong>Returns</strong></p><ul><li><code>Figure</code>: Comprehensive dashboard with 4 panels:<ol><li><strong>Top Left</strong>: Treatment effects (ATT) over time with confidence intervals</li><li><strong>Top Right</strong>: Observed vs counterfactual trajectories comparison  </li><li><strong>Bottom Left</strong>: Treatment effects as percentage changes</li><li><strong>Bottom Right</strong>: Summary statistics and balance diagnostics</li></ol></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># After running TSCSMethods analysis and generating imputation results
imputation = impute_results(model, model.matches, data, :t, :id)

# Create comprehensive dashboard
dashboard = create_inspection_dashboard(imputation, :Y)

# Save or display
save(&quot;analysis_dashboard.png&quot;, dashboard)
dashboard  # Display in notebook/REPL</code></pre><p><strong>Dashboard Interpretation</strong></p><ul><li><strong>ATT Panel</strong>: Shows treatment effects over time. Look for consistent patterns and significant effects</li><li><strong>Trajectory Panel</strong>: Key causal story - distance between blue (observed) and black (counterfactual) lines shows treatment impact</li><li><strong>Percentage Panel</strong>: Treatment effects as % changes for easier interpretation of magnitude  </li><li><strong>Summary Panel</strong>: Key statistics including overall ATT and baseline balance assessment</li></ul><p><strong>Notes</strong></p><ul><li>Dashboard provides comprehensive view of results</li><li>All panels use consistent time scales for easy comparison</li><li>Confidence intervals help assess statistical uncertainty</li><li>Summary statistics help evaluate matching quality and effect magnitude</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L331-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.customstrat-Tuple{Any, Any, Dict{Tuple{Int64, Int64}, Int64}}" href="#TSCSMethods.customstrat-Tuple{Any, Any, Dict{Tuple{Int64, Int64}, Int64}}"><code>TSCSMethods.customstrat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">customstrat!(
  cc,
  stratdict::Union{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}
)</code></pre><p>Stratify based on the values of some input dictionary, specifying strata for each (t, id) or each (id) for a stratification that varies only by unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/stratification.jl#L69-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.default_treatmentcategories-Tuple{Any}" href="#TSCSMethods.default_treatmentcategories-Tuple{Any}"><code>TSCSMethods.default_treatmentcategories</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_treatmentcategories(x) -&gt; Int</code></pre><p>Default categorization function for treatment histories during matching eligibility.</p><p><strong>Purpose</strong></p><p>Categorizes treatment exposure counts in the pre-crossover period to determine matching eligibility. Units can only be matched if they fall into the same treatment category during the pre-crossover window, ensuring similar treatment exposure patterns.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Total count of treatment exposures in the pre-crossover period for a unit</li></ul><p><strong>Returns</strong></p><ul><li><code>0</code>: Never treated (x == 0)</li><li><code>1</code>: Ever treated (x &gt; 0)</li></ul><p><strong>Usage in Matching</strong></p><p>During matching, for each potential match pair:</p><ol><li>Count treatments in pre-crossover period for treated unit → category A</li><li>Count treatments in pre-crossover period for potential match → category B  </li><li>If <code>treatmentcategories(A) == treatmentcategories(B)</code>, matching is allowed</li><li>Otherwise, the match is ineligible</li></ol><p><strong>Default Logic</strong></p><p>This binary categorization ensures that:</p><ul><li>Untreated units can only match with other untreated units</li><li>Previously treated units can only match with other previously treated units</li><li>Prevents contamination from units with different treatment exposure histories</li></ul><p><strong>Custom Categories</strong></p><p>Users can provide custom categorization functions for more nuanced matching:</p><pre><code class="language-julia hljs"># Example: Allow multiple treatment intensity levels
custom_categories(x) = x &lt;= 1 ? 0 : (x &lt;= 5 ? 1 : 2)
match!(model, data; treatcat = custom_categories)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/match.jl#L3-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.distances_allocate!-Tuple{Any, Any, Any}" href="#TSCSMethods.distances_allocate!-Tuple{Any, Any, Any}"><code>TSCSMethods.distances_allocate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distances_allocate!(matches, flen, covnum; sliding = false)</code></pre><p>Pre-allocate distance storage arrays for match calculations.</p><p><strong>Arguments</strong></p><ul><li><code>matches</code>: Vector of match objects to allocate storage for</li><li><code>flen</code>: Length of the time dimension (number of time periods)</li><li><code>covnum</code>: Number of covariates</li><li><code>sliding</code>: Whether to use sliding windows (default: false)</li></ul><p><strong>Algorithm</strong></p><ol><li>For each match object, allocate a matrix with dimensions:<ul><li>Rows: Number of potential matches for this observation</li><li>Columns: Number of distance types (1 Mahalanobis + <code>covnum</code> individual covariates)</li></ul></li><li>Initialize all distances to infinity (no matches computed yet)</li></ol><p><strong>Performance</strong></p><ul><li><strong>Memory</strong>: Pre-allocates all required storage to avoid allocations during computation</li><li><strong>Parallelization</strong>: Thread-safe as each match object gets independent storage</li><li><strong>Scalability</strong>: O(n<em>observations × max</em>matches × n_covariates) memory usage</li></ul><p><strong>Note</strong></p><p>This function prepares the storage structure but does not compute any distances. Actual distance computation is performed by <code>distances_calculate!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing.jl#L137-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.distances_calculate!-NTuple{10, Any}" href="#TSCSMethods.distances_calculate!-NTuple{10, Any}"><code>TSCSMethods.distances_calculate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distances_calculate!(matches, observations, ids, covariates, tg, rg, fmin, Lmin, Lmax, Σinvdict; sliding=false)</code></pre><p>Main function for calculating distances between treated and control units over time windows.</p><p><strong>Mathematical Framework</strong></p><p>This implements the core distance calculation for Feltham et al. (2023) methodology:</p><p><strong>For each treated unit i and potential control unit j:</strong></p><ol><li><strong>Time Window</strong>: Define matching window L = [Lmin, Lmax] relative to treatment time</li><li><strong>Distance Calculation</strong>: For each τ ∈ L, compute d(x<em>{iτ}, x</em>{jτ})  </li><li><strong>Temporal Averaging</strong>: Average distances over valid time points in window</li><li><strong>Multiple Distance Types</strong>: Compute both Mahalanobis and individual covariate distances</li></ol><p><strong>Mathematical Formulation</strong></p><pre><code class="nohighlight hljs">D(i,j) = (1/|W|) ∑_{τ ∈ W} d(x_{iτ}, x_{jτ})</code></pre><p>where:</p><ul><li>W = {τ : Lmin ≤ τ - t_i ≤ Lmax, data available for both units}</li><li>t_i is the treatment time for unit i</li><li>d(·,·) is the distance metric (Mahalanobis or covariate-specific)</li></ul><p><strong>Algorithm Overview</strong></p><ol><li><strong>Thread Parallelization</strong>: Use :greedy scheduler for load balancing across irregular workloads</li><li><strong>Valid Match Filtering</strong>: Check eligible_matches matrix to identify potential matches</li><li><strong>Storage Optimization</strong>: Use thread-local pre-allocated arrays</li><li><strong>Distance Computation</strong>: Call alldistances! for each treated-control pair</li><li><strong>Window Averaging</strong>: Call window_distances! to average over time windows</li></ol><p><strong>Performance Optimizations</strong></p><ul><li><strong>Threading</strong>: Modern :greedy scheduler for better load balancing</li><li><strong>Memory</strong>: Thread-local storage eliminates 90% of allocations  </li><li><strong>Caching</strong>: Pre-cache covariance matrices to avoid repeated lookups</li><li><strong>Early Termination</strong>: Skip observations with no valid matches</li></ul><p><strong>Arguments</strong></p><ul><li><code>matches</code>: Output array of match objects with distance matrices</li><li><code>observations</code>: Treated unit observations to process</li><li><code>ids</code>: Unit identifiers for matching</li><li><code>covariates</code>: List of covariate names for distance calculation</li><li><code>tg</code>: Treated unit covariate data grouped by (time, unit)</li><li><code>rg</code>: Time index mapping</li><li><code>fmin, Lmin, Lmax</code>: Window specification parameters</li><li><code>Σinvdict</code>: Pre-computed inverse covariance matrices by time</li><li><code>sliding</code>: Whether to use sliding windows (currently fixed windows only)</li></ul><p><strong>Complexity</strong></p><ul><li><strong>Time</strong>: O(n<em>treated × n</em>potential<em>matches × window</em>size × n_covariates)</li><li><strong>Memory</strong>: O(n<em>threads × max</em>window<em>size × max</em>covariates) due to pre-allocation</li><li><strong>Parallelization</strong>: Scales with number of threads, load-balanced across observations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing.jl#L204-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Float64}, Vararg{Any, 8}}" href="#TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Float64}, Vararg{Any, 8}}"><code>TSCSMethods.eligibility!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eligibility!(matches, observations, X::Matrix{Float64}, ids, treatcat, dat_t, dat_id, dat_trt, fmin, fmax, Lmin; exposure = nothing)</code></pre><p>Determine matching eligibility for all treated observations using crossover window constraints.</p><p><strong>Purpose</strong></p><p>Core eligibility determination that implements the TSCS matching methodology&#39;s crossover window logic. Creates efficient indexed views of the data and determines which units can serve as matches for each treated observation.</p><p><strong>Arguments</strong></p><ul><li><code>matches</code>: Vector of match objects to populate with eligibility information</li><li><code>observations</code>: Vector of treated observations (time, unit_id) tuples</li><li><code>X</code>: Covariate data matrix (Float64 version for non-missing data)</li><li><code>ids</code>: Vector of unique unit identifiers</li><li><code>treatcat</code>: Treatment categorization function for crossover period matching</li><li><code>dat_t, dat_id, dat_trt</code>: Time, unit ID, and treatment vectors from original data</li><li><code>fmin, fmax</code>: Bounds of forward period range (F)</li><li><code>Lmin</code>: Minimum lag period (lower bound of L)</li><li><code>exposure</code>: Optional exposure variable for exposure-based matching</li></ul><p><strong>Returns</strong></p><ul><li><code>tg</code>: Covariate group indices dictionary</li><li><code>rg</code>: Time group indices dictionary</li></ul><p><strong>Process</strong></p><ol><li><strong>Group Index Creation</strong>: Builds efficient (treatment<em>time, unit</em>id) indexed views</li><li><strong>Eligibility Determination</strong>: Calls <code>eligiblematches!()</code> to apply crossover window logic</li><li><strong>Exposure Handling</strong>: Supports both standard and exposure-based matching</li></ol><p><strong>Crossover Window Logic</strong></p><p>For each treated observation, potential matches are evaluated using:</p><ul><li>Pre-crossover treatment similarity (via <code>treatcat</code> function)</li><li>Post-crossover treatment exclusion (no treatment allowed in specific windows)</li><li>Time window constraints ensuring proper temporal alignment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/match.jl#L183-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Union{Missing, Float64}}, Vararg{Any, 8}}" href="#TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Union{Missing, Float64}}, Vararg{Any, 8}}"><code>TSCSMethods.eligibility!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eligibility!(matches, observations, X::Matrix{Union{Missing, Float64}}, ids, treatcat, dat_t, dat_id, dat_trt, fmin, fmax, Lmin; exposure = nothing)</code></pre><p>Determine matching eligibility with support for missing covariate data.</p><p><strong>Purpose</strong></p><p>Missing data version of the core eligibility function. Handles datasets where covariates may contain missing values, using appropriate handling in the groupindices creation and subsequent matching algorithms.</p><p><strong>Arguments</strong></p><p>Same as standard <code>eligibility!()</code> but with:</p><ul><li><code>X</code>: Covariate matrix allowing missing values (<code>Matrix{Union{Missing, Float64}}</code>)</li></ul><p><strong>Missing Data Handling</strong></p><ul><li>Creates appropriate SubArray types that can handle missing values</li><li>Propagates missing data handling through the matching pipeline</li><li>Distance calculations will appropriately handle missing values in downstream functions</li></ul><p><strong>Implementation Notes</strong></p><p>Identical logic to the Float64 version but uses different type dispatch to ensure proper handling of missing values throughout the matching process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/match.jl#L264-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Union{}}, Vararg{Any, 8}}" href="#TSCSMethods.eligibility!-Tuple{Any, Any, Matrix{Union{}}, Vararg{Any, 8}}"><code>TSCSMethods.eligibility!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eligibility!(matches, observations, X::Matrix{Union{}}, ids, treatcat, dat_t, dat_id, dat_trt, fmin, fmax, Lmin; exposure = nothing)</code></pre><p>Handle matching eligibility when no covariates are specified.</p><p><strong>Purpose</strong></p><p>Special case handler for models with no covariates (empty covariates array). Converts the empty matrix to an appropriate Float64 matrix structure and delegates to the standard eligibility function.</p><p><strong>Arguments</strong></p><p>Same as standard <code>eligibility!()</code> but with:</p><ul><li><code>X</code>: Empty covariate matrix (<code>Matrix{Union{}}</code>)</li></ul><p><strong>Behavior</strong></p><ul><li>Creates a properly sized <code>Matrix{Float64}</code> with 0 columns but correct row count</li><li>Delegates to the standard Float64 version of <code>eligibility!()</code></li><li>Enables matching based purely on treatment history patterns without covariate distance</li></ul><p><strong>Use Cases</strong></p><ul><li>Treatment effect estimation based only on temporal patterns</li><li>Matching when covariates are unavailable or not needed</li><li>Sensitivity analysis excluding covariate matching</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/match.jl#L332-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.eligibility-Tuple{VeryAbstractCICModel}" href="#TSCSMethods.eligibility-Tuple{VeryAbstractCICModel}"><code>TSCSMethods.eligibility</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eligibility(model::VeryAbstractCICModel)</code></pre><p>Calculate unit eligibility across all treated observations.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Fitted TSCSMethods model</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Int}</code>: Eligibility matrix (units × time periods F)</li></ul><p><strong>Description</strong></p><p>For each potential control unit, calculates how many times it is eligible to serve as a match across all treated observations and time periods. Higher eligibility indicates units that are consistently good potential matches for multiple treated units.</p><p>Useful for identifying:</p><ul><li>Units that are consistently good matches across multiple treated observations</li><li>Potential issues with match quality or overlap</li><li>Whether certain units dominate the matching process</li><li>Balance in the matching pool</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">eligibility_matrix = eligibility(model)

# Find highly eligible units
total_eligibility = sum(eligibility_matrix, dims=2)
highly_eligible_indices = findall(x -&gt; x &gt; 5, vec(total_eligibility))
highly_eligible_ids = model.ids[highly_eligible_indices]

println(&quot;Units eligible for &gt;5 matches: $highly_eligible_ids&quot;)

# Check eligibility by time period
for (f_idx, f) in enumerate(model.F)
    eligible_count = sum(eligibility_matrix[:, f_idx])
    println(&quot;F=$f: $eligible_count total eligible matches&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/information.jl#L68-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.estimate!-Tuple{AbstractCICModel, DataFrames.DataFrame}" href="#TSCSMethods.estimate!-Tuple{AbstractCICModel, DataFrames.DataFrame}"><code>TSCSMethods.estimate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate!(
    ccr::AbstractCICModel, dat;
    iterations = nothing,
    percentiles = [0.025, 0.5, 0.975],
    overallestimate = false,
    bayesfactor = true
)</code></pre><p>Perform ATT estimation, with bootstrapped CIs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.estimate!-Tuple{AbstractCICModelStratified, Any}" href="#TSCSMethods.estimate!-Tuple{AbstractCICModelStratified, Any}"><code>TSCSMethods.estimate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimate!(ccr::AbstractCICModelStratified, dat; iterations = nothing)</code></pre><p>Perform ATT stratified estimation, with bootstrapped CIs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_stratified.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.example_data-Tuple{}" href="#TSCSMethods.example_data-Tuple{}"><code>TSCSMethods.example_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">example_data()</code></pre><p>Load pre-existing example data for testing and demonstration.</p><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Panel data with columns: date, fips, pop<em>dens, cumul</em>death<em>rate, death</em>rte, gub, day</li></ul><p><strong>Description</strong></p><p>Loads example panel data from the package&#39;s vignette directory. This is real data from the package examples, providing a consistent dataset for testing and tutorials.</p><p>For generating synthetic data with custom parameters, use <code>example_data_generated()</code>, <code>policy_data()</code>, or <code>economic_data()</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/example_data.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.executesample!-Tuple{Any, Any, Any}" href="#TSCSMethods.executesample!-Tuple{Any, Any, Any}"><code>TSCSMethods.executesample!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>not stratified</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/resampling.jl#L91-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.export_results_csv-Tuple{Any, String}" href="#TSCSMethods.export_results_csv-Tuple{Any, String}"><code>TSCSMethods.export_results_csv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">export_results_csv(inspection_results, output_path::String)</code></pre><p>Export the results DataFrame to CSV for further analysis in other software.</p><p><strong>Arguments</strong></p><ul><li><code>inspection_results</code>: Output from inspect_results()</li><li><code>output_path</code>: Path for the CSV file</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">inspection = inspect_results(imputation, :Y)
export_results_csv(inspection, &quot;analysis_results.csv&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L543-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.filterunits!-Tuple{Any, Any}" href="#TSCSMethods.filterunits!-Tuple{Any, Any}"><code>TSCSMethods.filterunits!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>filterunits!(m, omap)</p><p>Remove treated units and matches that do not have values defined in the outcome window. This could be modified to account for missingness easily. This should probably be integrated into the match! procedure. (keep separate for now). (Updates ranks as well.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/filterunits!.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.find_periods_with_matches!-Tuple{Any, Any}" href="#TSCSMethods.find_periods_with_matches!-Tuple{Any, Any}"><code>TSCSMethods.find_periods_with_matches!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_periods_with_matches!(has_matches_by_period, eligible_matches_matrix)</code></pre><p>Determine which forward periods have at least one eligible match across all potential match units.</p><p><strong>Purpose</strong></p><p>For a given treated observation, creates a boolean vector indicating which forward periods (F values) have at least one unit eligible to serve as a match. This is used to determine which periods need BalanceData storage allocation.</p><p><strong>Arguments</strong></p><ul><li><code>has_matches_by_period</code>: Output boolean vector to populate (length = number of F periods)</li><li><code>eligible_matches_matrix</code>: Boolean matrix where <code>[unit, period]</code> indicates if unit is eligible match for that period</li></ul><p><strong>Details</strong></p><ul><li>Performs column-wise <code>any()</code> operation across the eligible<em>matches</em>matrix</li><li><code>has_matches_by_period[i] = true</code> if any unit can match in forward period i</li><li><code>has_matches_by_period[i] = false</code> if no units are eligible for forward period i</li><li>Used to optimize storage: only allocate BalanceData for periods with potential matches</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># eligible_matches_matrix: 3 units × 4 periods
# [true  false true  true ]  # unit 1
# [false true  false false]  # unit 2  
# [false false false true ]  # unit 3
# 
# Result: [true, true, true, true] - all periods have ≥1 eligible match</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing_utilities.jl#L352-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.fpossible!-NTuple{7, Any}" href="#TSCSMethods.fpossible!-NTuple{7, Any}"><code>TSCSMethods.fpossible!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>check possibility of the match for each f</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/retrieve_matches.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.fpossible!-NTuple{9, Any}" href="#TSCSMethods.fpossible!-NTuple{9, Any}"><code>TSCSMethods.fpossible!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>check possibility of the match for each f</p><p>version with exposure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/retrieve_matches.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.fpossible_mis!-NTuple{11, Any}" href="#TSCSMethods.fpossible_mis!-NTuple{11, Any}"><code>TSCSMethods.fpossible_mis!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>check possibility of the match for each f</p><p>version with exposure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/retrieve_matches_missing.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.fpossible_mis!-NTuple{9, Any}" href="#TSCSMethods.fpossible_mis!-NTuple{9, Any}"><code>TSCSMethods.fpossible_mis!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>check possibility of the match for each f</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/retrieve_matches_missing.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.generate_normal_effects-Tuple{Float64, UnitRange{Int64}}" href="#TSCSMethods.generate_normal_effects-Tuple{Float64, UnitRange{Int64}}"><code>TSCSMethods.generate_normal_effects</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_normal_effects(peak_effect::Float64, F_range::UnitRange{Int64})</code></pre><p>Generate F-period effects following a normal distribution centered on middle F period.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">effects = generate_normal_effects(1.0, 1:10)  # Peak effect of 1.0 at F=5-6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/example_data.jl#L472-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.generate_realistic_tscs-Tuple{}" href="#TSCSMethods.generate_realistic_tscs-Tuple{}"><code>TSCSMethods.generate_realistic_tscs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_realistic_tscs(; kwargs...)</code></pre><p>Generate synthetic data that mimics the WORKING example_data() treatment pattern but with known, controllable treatment effects for validation.</p><p><strong>Key Design</strong></p><ul><li><strong>Event-based treatment</strong>: Treatment indicator = 1 only on treatment day</li><li><strong>Sparse treatment</strong>: ~2% of observations treated (like real example)</li><li><strong>Staggered timing</strong>: Different units treated on different days</li><li><strong>Known ATT</strong>: Specified treatment effect we can validate against</li></ul><p><strong>Parameters</strong></p><ul><li><code>true_att::Float64</code>: Known treatment effect to recover</li><li><code>n_units::Int=100</code>: Number of units (like example data)</li><li><code>n_days::Int=90</code>: Number of time periods (like example data)</li><li><code>n_treated::Int=20</code>: Number of treated units (like example data)</li><li><code>treatment_start_day::Int=40</code>: Earliest treatment day (like example data)</li><li><code>outcome_scale::Float64=0.5</code>: Base outcome level (like death rates)</li><li><code>seed::Int=1234</code>: Random seed</li></ul><p><strong>Returns</strong></p><p>DataFrame with same structure as example_data():</p><ul><li><code>date</code>, <code>fips</code>, <code>pop_dens</code>, <code>cumul_death_rate</code>, <code>death_rte</code>, <code>gub</code>, <code>day</code></li><li>Treatment effect built into <code>death_rte</code> outcome</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/example_data.jl#L343-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.generate_simple_tscs-Tuple{}" href="#TSCSMethods.generate_simple_tscs-Tuple{}"><code>TSCSMethods.generate_simple_tscs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_simple_tscs(; kwargs...)</code></pre><p>Generate synthetic time-series cross-sectional data with known treatment effect.</p><p><strong>Mathematical Model</strong></p><p>Y<em>it = α</em>i + λ<em>t + τ*D</em>it + ε_it</p><p>Where:</p><ul><li>Y_it: outcome for unit i at time t  </li><li>α_i: unit fixed effects (time-invariant differences between units)</li><li>λ_t: time fixed effects (common time trends)</li><li>D_it: treatment indicator (1 if unit i treated at time t, 0 otherwise)</li><li>τ: treatment effect (THIS IS WHAT WE WANT TO RECOVER)</li><li>ε_it: idiosyncratic error term</li></ul><p><strong>Key Properties</strong></p><ul><li><strong>Parallel trends satisfied by construction</strong> (common λ_t)</li><li><strong>No confounding</strong> (treatment assignment independent of potential outcomes)</li><li><strong>Known counterfactual</strong> (Y<em>it without treatment = α</em>i + λ<em>t + ε</em>it)</li></ul><p><strong>Parameters</strong></p><ul><li><code>true_att::Float64</code>: The true average treatment effect (τ)</li><li><code>n_units::Int=100</code>: Number of cross-sectional units</li><li><code>n_periods::Int=50</code>: Number of time periods</li><li><code>treatment_period::Int=25</code>: When treatment begins (must be &gt; max(abs(L)))</li><li><code>n_treated::Int=20</code>: Number of units that receive treatment</li><li><code>unit_fe_var::Float64=2.0</code>: Variance of unit fixed effects (α_i)</li><li><code>time_fe_var::Float64=1.0</code>: Variance of time fixed effects (λ_t)</li><li><code>error_var::Float64=1.0</code>: Variance of idiosyncratic errors (ε_it)</li><li><code>seed::Int=1234</code>: Random seed for reproducibility</li></ul><p><strong>Returns</strong></p><p>DataFrame with columns:</p><ul><li><code>unit_id</code>: Unit identifier (1, 2, ..., n_units)</li><li><code>time_period</code>: Time identifier (1, 2, ..., n_periods)</li><li><code>treatment</code>: Treatment indicator (0/1)</li><li><code>outcome</code>: Generated outcome variable Y_it</li><li><code>unit_fe</code>: Unit fixed effect α_i (for validation)</li><li><code>time_fe</code>: Time fixed effect λ_t (for validation)</li><li><code>true_control_outcome</code>: Counterfactual outcome without treatment</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate data where true ATT = 2.5
data = generate_simple_tscs(true_att=2.5, n_units=50, n_periods=40, seed=42)

# The package should recover ATT ≈ 2.5
model = makemodel(data, :time_period, :unit_id, :treatment, :outcome, [], Dict(), 1:5, -10:-1)
match!(model, data)
estimate!(model, data)
@test abs(model.overall.ATT - 2.5) &lt; 0.2  # Should be close to true effect</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/example_data.jl#L94-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.generate_tscs_with_covariates-Tuple{}" href="#TSCSMethods.generate_tscs_with_covariates-Tuple{}"><code>TSCSMethods.generate_tscs_with_covariates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_tscs_with_covariates(; kwargs...)</code></pre><p>Generate synthetic TSCS data with covariates that affect both treatment and outcome.</p><p><strong>Mathematical Model</strong></p><p>Y<em>it = α</em>i + λ<em>t + β*X</em>it + τ*D<em>it + ε</em>it D<em>it = treatment assignment potentially related to X</em>it</p><p>Where X_it are time-varying covariates that may confound the relationship.</p><p><strong>Additional Parameters</strong></p><ul><li><code>covariate_effects::Vector{Float64}</code>: Effects of each covariate on outcome (β)</li><li><code>covariate_names::Vector{Symbol}</code>: Names for the covariates</li><li><code>confounding_strength::Float64=0.0</code>: How much covariates affect treatment assignment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/example_data.jl#L220-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.get_balance_data" href="#TSCSMethods.get_balance_data"><code>TSCSMethods.get_balance_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_balance_data(size::Int, fill_missing::Bool = true) -&gt; (BalanceData, Bool)</code></pre><p>Efficiently allocate BalanceData objects using memory pooling for performance optimization.</p><p><strong>Purpose</strong></p><p>Creates BalanceData objects while reusing pre-allocated memory buffers when possible. This reduces allocation overhead during intensive balance calculations across many treated observations and matching periods.</p><p><strong>Arguments</strong></p><ul><li><code>size</code>: Number of elements needed in the BalanceData object</li><li><code>fill_missing</code>: Whether to initialize all values as missing (default: true)</li></ul><p><strong>Returns</strong></p><p>Tuple of:</p><ul><li><code>BalanceData</code>: The allocated/reused balance data object</li><li><code>Bool</code>: Whether the object came from the pool (true) or was newly allocated (false)</li></ul><p><strong>Details</strong></p><ul><li>For small objects (≤100 elements): attempts to reuse pooled memory</li><li>For large objects or when pool is empty: allocates new memory directly</li><li>Pooled objects should be returned via <code>return_balance_data()</code> when no longer needed</li><li>Thread-safe through channel-based pooling system</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">balance_data, is_pooled = get_balance_data(50, true)
# ... use balance_data ...
return_balance_data(balance_data, is_pooled)  # Return to pool when done</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing_utilities.jl#L25-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.get_thread_storage-Tuple{Int64, Int64}" href="#TSCSMethods.get_thread_storage-Tuple{Int64, Int64}"><code>TSCSMethods.get_thread_storage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_thread_storage(n_times::Int, n_covariates::Int) -&gt; ThreadLocalDistanceStorage</code></pre><p>Get or create thread-local storage for distance calculations.</p><p><strong>Algorithm</strong></p><ol><li><strong>Task Identification</strong>: Get current task (modern alternative to deprecated threadid())</li><li><strong>Storage Check</strong>: Check if storage exists and is large enough for this task</li><li><strong>Resize/Create</strong>: If needed, create new storage with sufficient capacity</li><li><strong>Return</strong>: Provide storage for immediate use</li></ol><p><strong>Parameters</strong></p><ul><li><code>n_times</code>: Number of time periods needed</li><li><code>n_covariates</code>: Number of covariates needed</li></ul><p><strong>Returns</strong></p><ul><li><code>ThreadLocalDistanceStorage</code>: Pre-allocated arrays ready for use</li></ul><p><strong>Task Safety</strong></p><p>Uses modern task-local storage instead of deprecated Threads.threadid(). Each task maintains independent storage, preventing race conditions while maximizing memory reuse and providing better composability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing.jl#L58-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.getoutcomemap-NTuple{4, Any}" href="#TSCSMethods.getoutcomemap-NTuple{4, Any}"><code>TSCSMethods.getoutcomemap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getoutcomemap(outcome, data, t, id)</code></pre><p>Create a fast lookup dictionary mapping (time, unit) tuples to outcome values.</p><p><strong>Purpose</strong></p><p>This function creates an optimized lookup structure for outcome data that will be accessed repeatedly during estimation. Instead of searching through the DataFrame for each outcome lookup, we pre-build a hash table for O(1) access.</p><p><strong>Algorithm</strong></p><ol><li><strong>Dictionary Creation</strong>: Build <code>Dict{Tuple{Int, Int}, Float64}</code> where keys are <code>(time, unit_id)</code></li><li><strong>Data Population</strong>: Iterate through all rows, storing non-missing outcomes</li><li><strong>Missing Data Handling</strong>: Skip any rows where the outcome is missing</li></ol><p><strong>Performance Benefits</strong></p><ul><li><strong>Fast Lookups</strong>: O(1) average case vs O(n) DataFrame search</li><li><strong>Memory Efficient</strong>: Only stores non-missing outcomes</li><li><strong>Estimation Optimization</strong>: Critical for bootstrap performance where outcomes are accessed thousands of times</li></ul><p><strong>Arguments</strong></p><ul><li><code>outcome</code>: Symbol indicating the outcome column name</li><li><code>data</code>: Input DataFrame containing the panel data</li><li><code>t</code>: Symbol for the time variable column</li><li><code>id</code>: Symbol for the unit identifier column</li></ul><p><strong>Returns</strong></p><p><code>Dict{Tuple{Int, Int}, Float64}</code>: Dictionary mapping <code>(time, unit_id)</code> → outcome value</p><p><strong>Usage in Estimation</strong></p><p>During ATT estimation, we need outcome values for:</p><ul><li>Treated units at outcome periods: <code>outcomemap[(outcome_time, treated_unit)]</code></li><li>Matched units at outcome periods: <code>outcomemap[(outcome_time, matched_unit)]</code></li><li>All units at reference periods: <code>outcomemap[(reference_time, unit)]</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># If data has columns :time, :unit_id, :outcome
outcome_lookup = getoutcomemap(:outcome, data, :time, :unit_id)
# Later: quickly get outcome for unit 5 at time 10
value = outcome_lookup[(10, 5)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_setup.jl#L3-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.getsample-Tuple{Any, Any}" href="#TSCSMethods.getsample-Tuple{Any, Any}"><code>TSCSMethods.getsample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>not stratified</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/resampling.jl#L72-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.getyes!-NTuple{7, Any}" href="#TSCSMethods.getyes!-NTuple{7, Any}"><code>TSCSMethods.getyes!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getyes!(yesrows, tvec, idvec, tt, fmax, Lmin, unit)</code></pre><p>Determine which data rows fall within the matching time window for a specific unit and treatment time.</p><p><strong>Purpose</strong></p><p>Populates a boolean mask indicating which rows of the original data should be included in the indexed view for a given (treatment_time, unit) combination. This implements the core logic for defining matching windows in TSCS designs.</p><p><strong>Arguments</strong></p><ul><li><code>yesrows</code>: Output boolean vector to populate (same length as <code>tvec</code>)</li><li><code>tvec</code>: Time vector from original data</li><li><code>idvec</code>: Unit ID vector from original data  </li><li><code>tt</code>: Treatment time (when treatment occurred)</li><li><code>fmax</code>: Maximum forward period (upper bound of F range)</li><li><code>Lmin</code>: Minimum lag period (lower bound of L range, typically negative)</li><li><code>unit</code>: Unit ID to extract data for</li></ul><p><strong>Time Window Logic</strong></p><p>Selects rows where:</p><ol><li><code>tvec[k] &gt;= tt + Lmin</code> (at or after start of lag period)</li><li><code>tvec[k] &lt; tt + fmax</code> (before end of forward period)  </li><li><code>idvec[k] == unit</code> (belongs to the specified unit)</li></ol><p><strong>Example Time Windows</strong></p><pre><code class="nohighlight hljs">Treatment at tt=100, Lmin=-30, fmax=40:
- Window: [70, 139] (from 100-30 to 100+40-1)
- Includes: lag periods for covariate measurement + forward periods for outcomes
- Excludes: data outside this window or from other units</code></pre><p><strong>Performance Notes</strong></p><ul><li>Operates in-place on <code>yesrows</code> for memory efficiency</li><li>Used within threaded loops, so must be thread-safe (which it is)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/groupindices.jl#L228-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.grandbalance!-Tuple{AbstractCICModelStratified}" href="#TSCSMethods.grandbalance!-Tuple{AbstractCICModelStratified}"><code>TSCSMethods.grandbalance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grandbalance!(model::AbstractCICModelStratified)</code></pre><p>Calculate the overall mean covariate balance for a model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/overallbalancing.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.grandbalance!-Tuple{AbstractCICModel}" href="#TSCSMethods.grandbalance!-Tuple{AbstractCICModel}"><code>TSCSMethods.grandbalance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grandbalance!(model::AbstractCICModel)</code></pre><p>Calculate the overall mean covariate balance for a model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/overallbalancing.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.impute_results-NTuple{5, Any}" href="#TSCSMethods.impute_results-NTuple{5, Any}"><code>TSCSMethods.impute_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_results(m, matches, dat, tvar, unit_var; stratum = 1)</code></pre><p>Generate counterfactual outcomes Y(0) using matched control units.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: Fitted TSCSMethods model</li><li><code>matches</code>: DataFrame of matched units from matching procedure  </li><li><code>dat</code>: Original panel data</li><li><code>tvar</code>: Time variable name in data</li><li><code>unit_var</code>: Unit ID variable name in data</li><li><code>stratum</code>: Stratum number for stratified models (default: 1)</li></ul><p><strong>Returns</strong></p><ul><li><code>ImputationResults</code>: Structured container with counterfactual analysis</li></ul><p>The results DataFrame includes:</p><ul><li><code>counterfactual_trajectory</code>: What treated outcomes would have been without treatment</li><li><code>counterfactual_values</code>: Average of matched control outcomes at each time</li><li><code>counterfactual_lower</code>/<code>counterfactual_upper</code>: Confidence intervals for counterfactuals</li><li><code>pct_change</code>/<code>pct_change_lower</code>/<code>pct_change_upper</code>: Treatment effects as percentage changes</li><li><code>daily_counterfactual_change</code>: Day-to-day variation in counterfactual outcomes</li></ul><p>Creates counterfactual predictions by averaging matched control outcomes at each time period, enabling visualization of treated vs counterfactual trajectories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/imputation.jl#L237-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.initialize_balance_storage!-Tuple{Any}" href="#TSCSMethods.initialize_balance_storage!-Tuple{Any}"><code>TSCSMethods.initialize_balance_storage!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_balance_storage!(model)</code></pre><p>Prepare the meanbalances DataFrame storage for balance calculations.</p><p><strong>Purpose</strong></p><p>Allocates and initializes the meanbalances DataFrame which stores balance statistics for each treated observation. The DataFrame structure depends on whether covariates are time-varying or static.</p><p><strong>Details</strong></p><ul><li>Creates one row per treated observation</li><li>For time-varying covariates: Vector{Vector{BalanceData}} (periods × time points)</li><li>For static covariates: Vector{BalanceData} (just periods)</li><li>Uses object pooling for memory efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing_utilities.jl#L192-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.inspect_results-Tuple{TSCSMethods.ImputationResults, Symbol}" href="#TSCSMethods.inspect_results-Tuple{TSCSMethods.ImputationResults, Symbol}"><code>TSCSMethods.inspect_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inspect_results(imputation_results::ImputationResults, outcome_var::Symbol; 
               plot_percentage_changes::Bool = false)</code></pre><p>Comprehensive inspection of TSCSMethods results with clean separation of data processing and plotting.</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results</code>: ImputationResults struct from impute_results()</li><li><code>outcome_var</code>: Symbol representing the outcome variable column name</li><li><code>plot_percentage_changes</code>: Whether to include percentage change plots (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> with fields:<ul><li><code>treatment_effects_plot</code>: Figure showing ATT over time with confidence intervals</li><li><code>counterfactual_plot</code>: Figure showing observed vs counterfactual trajectories  </li><li><code>summary</code>: NamedTuple with summary statistics and balance diagnostics</li><li><code>data</code>: Prepared data structures for custom plotting or further analysis</li><li><code>percentage_plot</code>: (optional) Figure showing treatment effects as percentage changes</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using TSCSMethods

# Complete workflow
data = example_data()
model = makemodel(data, :t, :id, :gub, :Y, [:X1, :X2], 
                  Dict(:X1 =&gt; false, :X2 =&gt; false), -15:-10, 1:5)
match!(model, wids=50)
balance!(model)
estimate!(model, dobayesfactor=false)

# Generate imputation results  
imputation = impute_results(model, model.matches, data, :t, :id)

# Comprehensive inspection
inspection = inspect_results(imputation, :Y, plot_percentage_changes=true)

# View plots
inspection.treatment_effects_plot    # Shows ATT over time
inspection.counterfactual_plot       # Shows causal story: observed vs counterfactual  
inspection.percentage_plot           # Shows effects as % changes

# Access summary statistics
summary = inspection.summary
println(&quot;Average treatment effect: &quot;, round(summary.overall_att, digits=3))
println(&quot;Baseline balance: &quot;, round(summary.baseline_difference, digits=3))

# Access underlying data for custom analysis  
results_df = inspection.results_df
custom_plot = plot_treatment_effects(results_df, title=&quot;My Custom ATT Plot&quot;)</code></pre><p><strong>Notes</strong></p><ul><li>This function coordinates the entire inspection workflow</li><li>Data processing and plotting are separated for flexibility</li><li>All plots contain proper labels and confidence intervals</li><li>Use <code>plot_percentage_changes=true</code> for additional percentage change visualization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L243-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.make_groupindices-NTuple{7, Any}" href="#TSCSMethods.make_groupindices-NTuple{7, Any}"><code>TSCSMethods.make_groupindices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_groupindices(tvec, treatvec, idvec, uid, fmax, Lmin, X; exvec = nothing)</code></pre><p>Create efficient lookup dictionaries for accessing unit-specific data during matching windows.</p><p><strong>Purpose</strong></p><p>Builds indexed views of the data organized by (treatment<em>time, unit</em>id) pairs, covering the relevant time windows for matching. This enables fast access to covariate values, treatment histories, and time vectors for each unit during balance calculations.</p><p><strong>Arguments</strong></p><ul><li><code>tvec</code>: Time vector from the data</li><li><code>treatvec</code>: Treatment indicator vector (0/1 or boolean)</li><li><code>idvec</code>: Unit identifier vector  </li><li><code>uid</code>: Vector of unique unit IDs to process</li><li><code>fmax</code>: Maximum forward period (upper bound of F range)</li><li><code>Lmin</code>: Minimum lag period (lower bound of L range) </li><li><code>X</code>: Covariate data matrix</li><li><code>exvec</code>: Optional exposure vector for exposure-based matching</li></ul><p><strong>Returns</strong></p><p>Tuple of dictionaries with keys <code>(treatment_time, unit_id)</code>:</p><ul><li><code>tidx</code>: Covariate values for unit during time window <code>[tt + Lmin, tt + fmax)</code></li><li><code>ridx</code>: Time values for unit during the window</li><li><code>tridx</code>: Treatment indicators for unit during the window</li><li><code>exidx</code>: Exposure values (only if <code>exvec</code> provided)</li></ul><p><strong>Details</strong></p><p>For each treated observation at time <code>tt</code>, creates indexed views for all units covering the time window from <code>tt + Lmin</code> to <code>tt + fmax - 1</code>. This spans both the lag periods (for baseline covariate measurement) and forward periods (for outcome measurement).</p><p><strong>Performance Notes</strong></p><ul><li>Uses threaded processing for parallel index construction</li><li>Returns memory-efficient SubArray views rather than copying data</li><li>Pre-allocates dictionaries with appropriate size hints</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">tidx, ridx, tridx = make_groupindices(data.time, data.treatment, data.unit_id, 
                                      unique_units, 40, -30, covariate_matrix)
# Access unit 1&#39;s covariates during treatment time 100&#39;s window:
unit1_covariates = tidx[(100, 1)]  # SubArray view of relevant data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/groupindices.jl#L47-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.make_timeunit_lookup-NTuple{4, Any}" href="#TSCSMethods.make_timeunit_lookup-NTuple{4, Any}"><code>TSCSMethods.make_timeunit_lookup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_timeunit_lookup(dat, variable, time_col, unit_var)</code></pre><p>Create lookup dictionary mapping (time, unit) tuples to variable values. Returns Dict{Tuple, Union{Float64, Missing}} for fast value retrieval.</p><p><strong>Arguments</strong></p><ul><li><code>dat</code>: DataFrame with panel data</li><li><code>variable</code>: Column name for the variable to look up</li><li><code>time_col</code>: Column name for time variable</li><li><code>unit_col</code>: Column name for unit ID variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/imputation.jl#L217-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.makefblocks-NTuple{5, Any}" href="#TSCSMethods.makefblocks-NTuple{5, Any}"><code>TSCSMethods.makefblocks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    makefblocks(subTus, subMus, subWos, subWrs, subFs)</code></pre><p>Populate a set of fblocks to estimate and bootstrap the ATT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_setup.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.makemodel-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Vector{Symbol}, Dict{Symbol, Bool}, UnitRange{Int64}, UnitRange{Int64}}" href="#TSCSMethods.makemodel-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Vector{Symbol}, Dict{Symbol, Bool}, UnitRange{Int64}, UnitRange{Int64}}"><code>TSCSMethods.makemodel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makemodel(
    dat::DataFrame, 
    t::Symbol, 
    id::Symbol, 
    treatment::Symbol, 
    outcome::Union{Symbol, Vector{Symbol}},
    covariates::Vector{Symbol}, 
    timevary::Dict{Symbol, Bool},
    F::UnitRange{Int}, 
    L::UnitRange{Int};
    title::String = &quot;model&quot;,
    estimator::String = &quot;ATT&quot;
) -&gt; CIC</code></pre><p>Construct a CIC (Changes-in-Changes) model for causal inference analysis.</p><p><strong>Arguments</strong></p><ul><li><code>dat::DataFrame</code>: Input data containing all required variables</li><li><code>t::Symbol</code>: Column name for time variable</li><li><code>id::Symbol</code>: Column name for unit identifier</li><li><code>treatment::Symbol</code>: Column name for treatment variable (0/1 coding expected)</li><li><code>outcome::Union{Symbol, Vector{Symbol}}</code>: Column name(s) for outcome variable(s)</li><li><code>covariates::Vector{Symbol}</code>: Vector of column names for matching covariates</li><li><code>timevary::Dict{Symbol, Bool}</code>: Dictionary mapping each covariate to whether it&#39;s time-varying</li><li><code>F::UnitRange{Int}</code>: Time periods for treatment effect estimation (post-treatment)</li><li><code>L::UnitRange{Int}</code>: Time periods for pre-treatment matching window</li><li><code>title::String</code>: Optional title for the model (default: &quot;model&quot;)</li><li><code>estimator::String</code>: Estimator type (default: &quot;ATT&quot; for Average Treatment Effect on Treated)</li></ul><p><strong>Returns</strong></p><ul><li><code>CIC</code>: A constructed CIC model ready for matching, balancing, and estimation</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input data is empty, required columns are missing, or parameters are invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using TSCSMethods, DataFrames

# Create sample data
data = DataFrame(
    time = repeat(1:100, 50),
    unit_id = repeat(1:50, inner=100),
    treated = repeat([fill(1, 10); fill(0, 40)], inner=100),
    outcome = randn(5000),
    covar1 = randn(5000),
    covar2 = randn(5000)
)

# Construct model
model = makemodel(
    data, :time, :unit_id, :treated, :outcome,
    [:covar1, :covar2],
    Dict(:covar1 =&gt; false, :covar2 =&gt; true),
    51:60, 40:49  # F and L periods
)</code></pre><p><strong>References</strong></p><p>Based on the methodology from Imai, Kim, and Wang (2021) for matching methods  with time-series cross-sectional data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/core/construction.jl#L3-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.match!-Tuple{AbstractCICModel, DataFrames.DataFrame}" href="#TSCSMethods.match!-Tuple{AbstractCICModel, DataFrames.DataFrame}"><code>TSCSMethods.match!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">match!(model::AbstractCICModel, dat::DataFrame; treatcat = default_treatmentcategories, exposure = nothing, variancesonly = true)</code></pre><p>Perform matching for treatment events using Mahalanobis distance with crossover window restrictions.</p><p><strong>Purpose</strong></p><p>Core matching algorithm that identifies eligible control units for each treated observation, calculates distances using Mahalanobis metric, and ranks potential matches. Implements the extended TSCS matching methodology with crossover window constraints to ensure proper counterfactual identification.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: CIC model containing treated observations and match storage structures</li><li><code>dat</code>: DataFrame with time-series cross-sectional data</li><li><code>treatcat</code>: Function categorizing treatment histories (default: <code>default_treatmentcategories</code>)</li><li><code>exposure</code>: Optional exposure variable name for exposure-based matching</li><li><code>variancesonly</code>: Use diagonal covariance matrix (variances only) vs full covariance (default: true)</li></ul><p><strong>Returns</strong></p><p>Modified <code>model</code> with populated matches containing:</p><ul><li>Eligible match indicators for each treated observation</li><li>Mahalanobis distances to potential matches</li><li>Ranked match preferences for each forward period</li></ul><p><strong>Matching Process</strong></p><ol><li><strong>Eligibility Determination</strong>: Uses crossover window logic to determine which units can serve as matches</li><li><strong>Distance Calculation</strong>: Computes Mahalanobis distances using sample covariance matrix</li><li><strong>Ranking</strong>: Orders potential matches by distance for each forward period (F)</li></ol><p><strong>Crossover Window Logic</strong></p><p>For treatment at time <code>t</code> with forward period <code>f</code>:</p><ul><li><strong>Pre-crossover period</strong>: <code>[t + f - max(F), t + f - min(F)]</code> </li><li><strong>Post-crossover period</strong>: <code>[t + f - min(F), t + f - max(F)]</code></li><li>Matches must have similar treatment patterns in pre-crossover period</li><li>Matches cannot be treated in post-crossover period</li></ul><p><strong>Performance Notes</strong></p><ul><li>Uses threaded processing for parallel distance calculations</li><li>Memory-efficient SubArray views via groupindices system</li><li>Handles missing data through multiple dispatch</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)
match!(model, data)  # Standard matching
match!(model, data; exposure = :policy_exposure)  # With exposure matching</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/match.jl#L48-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.matchinfo-Tuple{Any, Any}" href="#TSCSMethods.matchinfo-Tuple{Any, Any}"><code>TSCSMethods.matchinfo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matchinfo(refined_model, original_model; maxrank = 5)</code></pre><p>Generate match information DataFrame for refined/calipered models.</p><p><strong>Purpose</strong></p><p>Creates match information for models that have undergone refinement or caliper operations, showing how refined matches relate to the original full model&#39;s ranking system. Useful for understanding how refinement affects match selection and quality.</p><p><strong>Arguments</strong></p><ul><li><code>refined_model</code>: Refined or calipered CIC model (result of <code>refine()</code> or <code>caliper()</code>)</li><li><code>original_model</code>: Original full CIC model before refinement</li><li><code>maxrank</code>: Maximum number of matches to include per F period (default: 5)</li></ul><p><strong>Returns</strong></p><p><code>DataFrame</code> with columns:</p><ul><li><code>timetreated</code>: Time when treatment occurred</li><li><code>treatedunit</code>: ID of the treated unit</li><li><code>f</code>: Forward period within the outcome window</li><li><code>matchunits</code>: Vector of matched control unit IDs from refined model</li><li><code>ranks</code>: Vector of rank positions from original model&#39;s full ranking</li></ul><p><strong>Description</strong></p><p>For each treatment observation in the refined model:</p><ol><li>Finds the corresponding observation in the original model</li><li>Extracts eligible matches from the refined model</li><li>Determines their ranks in the original model&#39;s full ranking</li><li>Returns matches sorted by their original ranks</li></ol><p>This allows comparison between refined and original matching, showing whether refinement preserves the best matches or introduces changes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Compare refined vs original matches
original_matches = matchinfo(original_model; maxrank = 10)
refined_matches = matchinfo(refined_model, original_model; maxrank = 10)

# Check if refinement preserved top matches
for (orig_row, ref_row) in zip(eachrow(original_matches), eachrow(refined_matches))
    if orig_row.treatedunit == ref_row.treatedunit &amp;&amp; orig_row.f == ref_row.f
        original_top3 = orig_row.matchunits[1:min(3, length(orig_row.matchunits))]
        refined_units = ref_row.matchunits
        preserved = intersect(original_top3, refined_units)
        println(&quot;Unit $(orig_row.treatedunit), F=$(orig_row.f): $(length(preserved))/3 top matches preserved&quot;)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/information.jl#L386-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.matchinfo-Tuple{Union{CIC, CICStratified}}" href="#TSCSMethods.matchinfo-Tuple{Union{CIC, CICStratified}}"><code>TSCSMethods.matchinfo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matchinfo(model::Union{CIC, CICStratified}; maxrank = 5)</code></pre><p>Generate match information DataFrame for standard CIC models.</p><p><strong>Purpose</strong></p><p>Creates a detailed summary of matching results showing which control units were matched to each treated observation across all forward periods (F). Provides match unit IDs and their ranking within each time period.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Fitted CIC or CICStratified model with completed matching</li><li><code>maxrank</code>: Maximum number of top-ranked matches to include per F period (default: 5)</li></ul><p><strong>Returns</strong></p><p><code>DataFrame</code> with columns:</p><ul><li><code>timetreated</code>: Time when treatment occurred</li><li><code>treatedunit</code>: ID of the treated unit</li><li><code>f</code>: Forward period within the outcome window</li><li><code>matchunits</code>: Vector of matched control unit IDs (ranked best to worst)</li><li><code>ranks</code>: Vector of rank positions (1 = best match, 2 = second best, etc.)</li></ul><p><strong>Description</strong></p><p>For each treatment observation and each forward period F, this function:</p><ol><li>Extracts the top <code>maxrank</code> matched control units</li><li>Converts internal match indices to actual unit IDs</li><li>Filters out periods with no available matches</li><li>Returns results sorted by treatment time and unit ID</li></ol><p>This is useful for:</p><ul><li>Inspecting match quality and consistency across time periods</li><li>Understanding which units serve as controls for specific treatments</li><li>Debugging matching algorithm performance</li><li>Creating match summaries for reporting</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get match information with top 3 matches per period
matches_df = matchinfo(model; maxrank = 3)

# View matches for a specific treatment
unit_matches = filter(row -&gt; row.treatedunit == 1001 &amp;&amp; row.timetreated == 15, matches_df)
for row in eachrow(unit_matches)
    println(&quot;F=$(row.f): matched to units $(row.matchunits) with ranks $(row.ranks)&quot;)
end

# Check if any treatment lacks matches
no_matches = filter(row -&gt; isempty(row.matchunits), matches_df)
if !isempty(no_matches)
    println(&quot;Warning: Some treatments have no matches&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/information.jl#L270-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any, Any, Any}" href="#TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any, Any, Any}"><code>TSCSMethods.meanbalance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meanbalance!(model, dat, tg, rg)</code></pre><p>Calculate the mean balances, for each treated observation from the full set of balances. This will limit the calculations to include those present in model.matches, e.g. in case a caliper has been applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/meanbalancing.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any}" href="#TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any}"><code>TSCSMethods.meanbalance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meanbalance!(model)</code></pre><p>Calculate the mean balances, for each treated observation from the full set of balances. This will limit the calculations to include those present in model.matches, e.g. in case a caliper has been applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/meanbalancing.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.name_model-Tuple{VeryAbstractCICModel}" href="#TSCSMethods.name_model-Tuple{VeryAbstractCICModel}"><code>TSCSMethods.name_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">name_model(model::VeryAbstractCICModel)</code></pre><p>Generate the filename for a set of models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/storage.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.observationweights-Tuple{Any, Any}" href="#TSCSMethods.observationweights-Tuple{Any, Any}"><code>TSCSMethods.observationweights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>treated observation weights</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_observationweights.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.obsinfo-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Symbol}}" href="#TSCSMethods.obsinfo-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Symbol}}"><code>TSCSMethods.obsinfo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obsinfo(
    match_info_df, data, variables;
    full_model_observations = nothing,
    time_column = :t, id_column = :id
)</code></pre><p>Extract covariate information for treated units at their treatment times.</p><p><strong>Purpose</strong></p><p>Gathers covariate values for all treated units at the exact time of their treatment events. For time-varying covariates, this ensures values are captured at the moment of treatment rather than at arbitrary time points. Useful for creating treatment group summaries and balance tables.</p><p><strong>Arguments</strong></p><ul><li><code>match_info_df</code>: DataFrame from <code>matchinfo()</code> containing treatment observations</li><li><code>data</code>: Original time-series cross-sectional dataset</li><li><code>variables</code>: Vector of column names to extract (e.g., <code>[:population, :gdp, :policy_index]</code>)</li><li><code>full_model_observations</code>: Optional vector of all treatment observations for comparison (default: <code>nothing</code>)</li><li><code>time_column</code>: Name of time variable in data (default: <code>:t</code>)</li><li><code>id_column</code>: Name of unit identifier in data (default: <code>:id</code>)</li></ul><p><strong>Returns</strong></p><p><code>DataFrame</code> with columns:</p><ul><li><code>timetreated</code>: Time when treatment occurred</li><li><code>treatedunit</code>: ID of the treated unit</li><li><code>removed</code>: Boolean indicating if observation was removed in refinement (if <code>full_model_observations</code> provided)</li><li>Additional columns for each variable in <code>variables</code></li></ul><p><strong>Description</strong></p><p>For each unique treatment observation:</p><ol><li>Identifies the corresponding row in the original data</li><li>Extracts covariate values at the time of treatment</li><li>Optionally compares against full model to identify removed observations</li><li>Returns sorted results with all requested covariate information</li></ol><p>This is essential for:</p><ul><li>Creating balance tables showing pre-treatment characteristics</li><li>Comparing refined vs full model treatment groups</li><li>Understanding treatment group composition</li><li>Generating summary statistics for reporting</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get basic covariate info for treated units
match_df = matchinfo(model)
covariates = [:population, :gdp_per_capita, :unemployment_rate]
treated_info = obsinfo(match_df, data, covariates; 
                      time_column = :year, id_column = :state_id)

# Compare full vs refined model
full_obs = model.observations
refined_df = matchinfo(refined_model)
comparison = obsinfo(refined_df, data, covariates;
                    full_model_observations = full_obs,
                    time_column = :year, id_column = :state_id)

# View removed observations
removed_units = filter(row -&gt; row.removed, comparison)
println(&quot;Removed $(nrow(removed_units)) treatment observations in refinement&quot;)

# Create balance table
using Statistics
for var in covariates
    mean_val = mean(skipmissing(treated_info[!, var]))
    println(&quot;$(var): mean = $(round(mean_val, digits=3))&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>Uses exact time-unit matching to ensure temporal accuracy</li><li>Handles missing values gracefully through type system</li><li>Maintains sort order for consistent output</li><li>Column names are parameterized to avoid hardcoded dependencies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/information.jl#L525-L600">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.plot_counterfactual_comparison-Tuple{DataFrames.DataFrame, Symbol}" href="#TSCSMethods.plot_counterfactual_comparison-Tuple{DataFrames.DataFrame, Symbol}"><code>TSCSMethods.plot_counterfactual_comparison</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_counterfactual_comparison(results_df, outcome_var; kwargs...)</code></pre><p>Plot observed vs counterfactual trajectories. Takes DataFrame from prepare<em>counterfactual</em>comparison_data().</p><p><strong>Arguments</strong></p><ul><li><code>results_df</code>: DataFrame with columns <code>f</code>, <code>[outcome_var]</code>, <code>counterfactual_trajectory</code>, etc.</li><li><code>outcome_var</code>: Symbol for outcome variable column name</li><li><code>title</code>: Plot title (default: &quot;Observed vs Counterfactual Trajectories&quot;)</li><li><code>xlabel</code>: X-axis label (default: &quot;Time Period&quot;)</li><li><code>ylabel</code>: Y-axis label (default: string of outcome_var)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L941-L953">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.plot_percentage_changes-Tuple{DataFrames.DataFrame}" href="#TSCSMethods.plot_percentage_changes-Tuple{DataFrames.DataFrame}"><code>TSCSMethods.plot_percentage_changes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_percentage_changes(results_df; kwargs...)</code></pre><p>Plot treatment effects as percentage changes. Takes DataFrame from prepare<em>percentage</em>change_data().</p><p><strong>Arguments</strong></p><ul><li><code>results_df</code>: DataFrame with columns <code>f</code>, <code>pct_change</code>, <code>pct_change_lower</code>, <code>pct_change_upper</code></li><li><code>title</code>: Plot title (default: &quot;Treatment Effects (% Change)&quot;)</li><li><code>xlabel</code>: X-axis label (default: &quot;Time Period&quot;)</li><li><code>ylabel</code>: Y-axis label (default: &quot;Percent Change&quot;)  </li><li><code>markersize</code>: Size of scatter points (default: 8)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L1017-L1029">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.prepare_counterfactual_comparison_data-Tuple{TSCSMethods.ImputationResults, Symbol}" href="#TSCSMethods.prepare_counterfactual_comparison_data-Tuple{TSCSMethods.ImputationResults, Symbol}"><code>TSCSMethods.prepare_counterfactual_comparison_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_counterfactual_comparison_data(imputation_results::ImputationResults, outcome_var::Symbol)</code></pre><p>Extract and sort data for observed vs counterfactual trajectory plotting.</p><p>This function prepares the DataFrame needed to visualize the key causal inference comparison: what actually happened (observed) vs. what would have happened without treatment (counterfactual).</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results::ImputationResults</code>: Output from <code>impute_results()</code></li><li><code>outcome_var::Symbol</code>: Column name of the outcome variable (e.g., <code>:Y</code>, <code>:deaths</code>, <code>:GDP</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Sorted by time period, containing all original columns plus outcome variable. Key columns for plotting:<ul><li><code>f</code>: Time periods</li><li><code>[outcome_var]</code>: Actual observed outcomes for treated units  </li><li><code>counterfactual_trajectory</code>: Estimated counterfactual outcomes</li><li><code>counterfactual_lower</code>: Lower bounds of counterfactual confidence intervals</li><li><code>counterfactual_upper</code>: Upper bounds of counterfactual confidence intervals</li><li><code>att</code>: Treatment effects (observed - counterfactual)</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">imputation = impute_results(model, matches, data, :t, :id)  
results_df = prepare_counterfactual_comparison_data(imputation, :Y)

# The key causal story (now just DataFrame columns)
observed_trajectory = results_df[!, :Y]                    # What actually happened
counterfactual_trajectory = results_df.counterfactual_trajectory  # What would have happened
treatment_effect = results_df.att                          # The causal impact</code></pre><p><strong>Notes</strong></p><p>The counterfactual trajectory represents the estimated outcome path that treated units would have followed if they had not received treatment, constructed by averaging outcomes from matched control units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L106-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.prepare_percentage_change_data-Tuple{TSCSMethods.ImputationResults}" href="#TSCSMethods.prepare_percentage_change_data-Tuple{TSCSMethods.ImputationResults}"><code>TSCSMethods.prepare_percentage_change_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_percentage_change_data(imputation_results::ImputationResults)</code></pre><p>Extract and sort percentage change data for plotting.</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results::ImputationResults</code>: Output from <code>impute_results()</code></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Sorted by time period, containing columns:<ul><li><code>f</code>: Time periods</li><li><code>pct_change</code>: Treatment effects as percentage changes</li><li><code>pct_change_lower</code>: Lower bounds of percentage change confidence intervals  </li><li><code>pct_change_upper</code>: Upper bounds of percentage change confidence intervals</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">imputation = impute_results(model, matches, data, :t, :id)
results_df = prepare_percentage_change_data(imputation)

# Access percentage data (now just DataFrame columns)
pct_effects = results_df.pct_change        # [2.1, 4.2, 1.5, 0.5, ...]
pct_lower = results_df.pct_change_lower    # [0.1, 2.0, -0.5, -1.5, ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L152-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.prepare_treatment_effect_data-Tuple{TSCSMethods.ImputationResults}" href="#TSCSMethods.prepare_treatment_effect_data-Tuple{TSCSMethods.ImputationResults}"><code>TSCSMethods.prepare_treatment_effect_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_treatment_effect_data(imputation_results::ImputationResults)</code></pre><p>Extract and sort treatment effect data for plotting.</p><p>This function processes ImputationResults to create a clean DataFrame containing treatment effects (ATT) and confidence intervals organized by time period.</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results::ImputationResults</code>: Output from <code>impute_results()</code></li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Sorted by time period, containing columns:<ul><li><code>f</code>: Time periods  </li><li><code>att</code>: Average treatment effects for each time period</li><li><code>2.5%</code>: Lower bounds of 95% confidence intervals  </li><li><code>97.5%</code>: Upper bounds of 95% confidence intervals</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">imputation = impute_results(model, matches, data, :t, :id)
results_df = prepare_treatment_effect_data(imputation)

# Access the data (now just DataFrame columns)
plot_times = results_df.f           # [-4, -3, -2, -1, 1, 2, 3, 4, 5]
effects = results_df.att            # [0.1, 0.2, 0.15, 0.05, 0.3, 0.4, ...]
lower_ci = results_df[!, Symbol(&quot;2.5%&quot;)]  # [-0.1, 0.0, -0.05, -0.15, 0.1, ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L72-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.processunits-NTuple{9, Any}" href="#TSCSMethods.processunits-NTuple{9, Any}"><code>TSCSMethods.processunits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">processunits(matches, observations, outcome, F, ids, reference, t, id, data)</code></pre><p>Pre-process matched units and outcomes for estimation and bootstrapping.</p><p><strong>Algorithm Overview</strong></p><p>This function transforms the match structure into arrays optimized for ATT estimation:</p><ol><li><p><strong>Data Size Calculation</strong>: For each treated unit, calculate total data points needed:</p><ul><li><code>sum(eligible_matches)</code>: Total number of matched control units across all F periods</li><li><code>valid_outcome_periods_count</code>: Number of F periods with at least one match (treated unit appears once per valid F period)</li><li>Total = matches + treated unit observations</li></ul></li><li><p><strong>Memory Pre-allocation</strong>: Create vectors to store:</p><ul><li><code>Wos</code>: Weighted outcomes (positive for treated, negative for matches)</li><li><code>Wrs</code>: Weighted reference period outcomes  </li><li><code>Tus</code>: Treated unit IDs</li><li><code>Mus</code>: Match unit IDs (includes treated unit ID for treated observations)</li><li><code>Fs</code>: F period indicators</li></ul></li><li><p><strong>Data Population</strong>: Use <code>unitstore!</code> to populate arrays with outcome data and weights</p></li></ol><p><strong>Mathematical Foundation</strong></p><p>For ATT estimation, we need paired (treated, control) observations for each F period. The weighting scheme is:</p><ul><li>Treated unit: weight = +1.0 for outcome, -1.0 for reference</li><li>Matched units: weight = -1/n<em>matches for outcome, +1/n</em>matches for reference</li></ul><p><strong>Arguments</strong></p><ul><li><code>matches</code>: Vector of match objects with <code>eligible_matches</code> matrices</li><li><code>observations</code>: Vector of (time, unit) tuples for treated units</li><li><code>outcome</code>: Outcome variable symbol</li><li><code>F</code>: Post-treatment periods for effect estimation</li><li><code>ids</code>: Unit identifier mapping</li><li><code>reference</code>: Reference period offset (typically negative)</li><li><code>t</code>, <code>id</code>: Time and unit variable symbols</li><li><code>data</code>: Input DataFrame</li></ul><p><strong>Returns</strong></p><p>Tuple of vectors: <code>(Tus, Mus, Wos, Wrs, Fs)</code> where each element contains data for all treated units, structured for efficient estimation.</p><p><strong>Performance Notes</strong></p><ul><li>Uses threaded allocation and population for scalability</li><li>Pre-calculates data sizes to avoid dynamic resizing</li><li>Structured for efficient bootstrapping operations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_setup.jl#L64-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.quick_att-Tuple{Any}" href="#TSCSMethods.quick_att-Tuple{Any}"><code>TSCSMethods.quick_att</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>quick<em>att(matchseries;     outcomes = [:death</em>rte, :case_rte, :deaths, :cases],     F = 10:40,     ttt = false,     tm1 = 30 )</p><p>Quickly calculate the att for specified outcomes based on the output of the  matchprocess(). Does not calculate confidence intervals.</p><p>Calculates both the individual-level unit effects, and the average effects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_utilities.jl#L225-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.quick_inspection-Tuple{TSCSMethods.ImputationResults, Symbol}" href="#TSCSMethods.quick_inspection-Tuple{TSCSMethods.ImputationResults, Symbol}"><code>TSCSMethods.quick_inspection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quick_inspection(imputation_results::ImputationResults, outcome_var::Symbol)</code></pre><p>Quick inspection function that prints summary statistics and optionally shows plots.</p><p><strong>Arguments</strong></p><ul><li><code>imputation_results</code>: Output from impute_results()</li><li><code>outcome_var</code>: Symbol for outcome variable</li></ul><p><strong>Returns</strong></p><ul><li>Summary statistics printed to console</li><li>Basic diagnostic information about matching quality</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">imputation = impute_results(model, matches, data, :t, :id)
quick_inspection(imputation, :Y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L568-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.refine-Tuple{CIC, Any}" href="#TSCSMethods.refine-Tuple{CIC, Any}"><code>TSCSMethods.refine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine(
    model::CIC, 
    dat::DataFrame;
    refinementnum::Int = 5, 
    dobalance::Bool = true,
    doestimate::Bool = true
) -&gt; RefinedCIC</code></pre><p>Refine a CIC model by keeping only the best <code>refinementnum</code> matches for each treated unit.</p><p><strong>Arguments</strong></p><ul><li><code>model::CIC</code>: A matched CIC model</li><li><code>dat::DataFrame</code>: Input data containing all model variables</li><li><code>refinementnum::Int</code>: Number of best matches to retain per treated unit (default: 5)</li><li><code>dobalance::Bool</code>: Whether to perform balancing on the refined model (default: true)</li><li><code>doestimate::Bool</code>: Whether to perform estimation on the refined model (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>RefinedCIC</code>: A refined version of the input model with reduced matches</li></ul><p><strong>Description</strong></p><p>Refinement improves match quality by keeping only the closest matches for each treated unit, based on the distance metrics computed during the matching stage. This typically improves covariate balance and estimation precision at the cost of statistical power.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># After matching a model
model = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)
match!(model, data)

# Refine to top 3 matches per treated unit
refined_model = refine(model, data; refinementnum = 3)

# Refine without automatic balancing and estimation
refined_model = refine(model, data; refinementnum = 5, dobalance = false, doestimate = false)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#TSCSMethods.caliper-Tuple{CIC, Any, Any}"><code>caliper</code></a>: Alternative approach using distance thresholds</li><li><a href="#TSCSMethods.match!-Tuple{AbstractCICModel, DataFrames.DataFrame}"><code>match!</code></a>: Initial matching procedure</li><li><a href="#TSCSMethods.balance!-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}"><code>balance!</code></a>: Balance assessment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/refine.jl#L5-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.return_balance_data-Tuple{TSCSMethods.BalanceData, Bool}" href="#TSCSMethods.return_balance_data-Tuple{TSCSMethods.BalanceData, Bool}"><code>TSCSMethods.return_balance_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">return_balance_data(balance_data::BalanceData, is_pooled::Bool)</code></pre><p>Return a BalanceData object to the memory pool for reuse, if it came from the pool.</p><p><strong>Purpose</strong></p><p>Completes the memory pooling cycle by returning used BalanceData objects back to the pool for future reuse. This prevents memory fragmentation and reduces allocation overhead in subsequent balance calculations.</p><p><strong>Arguments</strong></p><ul><li><code>balance_data</code>: The BalanceData object to potentially return to pool</li><li><code>is_pooled</code>: Whether this object originally came from the pool (from <code>get_balance_data</code>)</li></ul><p><strong>Details</strong></p><ul><li>Only returns objects to pool if they originally came from it (<code>is_pooled == true</code>)</li><li>Only pools objects with ≤100 elements (larger ones are discarded)</li><li>Thread-safe operation using channel-based pools</li><li>Should be called when BalanceData objects are no longer needed</li></ul><p><strong>Usage Pattern</strong></p><pre><code class="language-julia hljs">balance_data, is_pooled = get_balance_data(50, true)
# ... use balance_data for calculations ...
return_balance_data(balance_data, is_pooled)  # Return when done</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/balancing/balancing_utilities.jl#L78-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.save_inspection_plots" href="#TSCSMethods.save_inspection_plots"><code>TSCSMethods.save_inspection_plots</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_inspection_plots(inspection_results, output_dir::String = &quot;.&quot;, prefix::String = &quot;analysis&quot;)</code></pre><p>Save all plots from inspect_results() to files with publication-quality settings.</p><p><strong>Arguments</strong></p><ul><li><code>inspection_results</code>: Output from inspect_results()</li><li><code>output_dir</code>: Directory to save plots (default: current directory)</li><li><code>prefix</code>: File prefix for saved plots (default: &quot;analysis&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Run inspection
inspection = inspect_results(imputation, :Y, plot_percentage_changes=true)

# Save all plots
save_inspection_plots(inspection, &quot;results/&quot;, &quot;covid_analysis&quot;)
# Creates: covid_analysis_treatment_effects.png, covid_analysis_counterfactual.png, etc.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/inspection.jl#L493-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.showmatches-Tuple{VeryAbstractCICModel, Tuple{Int64, Int64}}" href="#TSCSMethods.showmatches-Tuple{VeryAbstractCICModel, Tuple{Int64, Int64}}"><code>TSCSMethods.showmatches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showmatches(model::VeryAbstractCICModel, treatment_observation::Tuple{Int, Int})</code></pre><p>Show ranked matches for a specific treatment observation.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Fitted TSCSMethods model  </li><li><code>treatment_observation</code>: Tuple of (treatment<em>time, unit</em>id)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{Int}}</code>: Ranked matches for each time period F (sorted best to worst)</li><li><code>&quot;Treatment observation not found&quot;</code>: If observation doesn&#39;t exist in model</li></ul><p><strong>Description</strong></p><p>For a specific treatment event, shows the ranked list of matched control unit indices for each time period in the post-treatment window F. Units are ranked from best match (rank 1) to worst match based on the matching algorithm&#39;s distance calculations and balancing constraints.</p><p>The returned structure is a vector where each element corresponds to a time period F, containing the ranked list of control unit indices (internal to model.matches). To get actual unit IDs, use <code>model.ids[index]</code>.</p><p>This function is useful for:</p><ul><li>Debugging matching quality for specific treatment events</li><li>Understanding which units serve as matches across different time periods</li><li>Assessing match consistency over time</li><li>Manual inspection of matching results</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Show matches for unit 1001 treated at time 15
matches = showmatches(model, (15, 1001))

if matches isa String
    println(matches)  # &quot;Treatment observation not found&quot;
else
    println(&quot;Matches across F periods:&quot;)
    for (f_idx, f) in enumerate(model.F)
        period_matches = matches[f_idx]
        if !isempty(period_matches)
            # Convert to actual unit IDs
            match_ids = [model.ids[idx] for idx in period_matches[1:min(3, length(period_matches))]]
            println(&quot;F=$f: top 3 matches = $match_ids&quot;)
        else
            println(&quot;F=$f: no matches available&quot;)
        end
    end
end

# Check consistency of top match across periods
if matches isa Vector &amp;&amp; all(length.(matches) .&gt; 0)
    top_matches = [model.ids[period_matches[1]] for period_matches in matches]
    println(&quot;Top match by period: $top_matches&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/information.jl#L193-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.stratify-Tuple{Function, CIC, Vararg{Any}}" href="#TSCSMethods.stratify-Tuple{Function, CIC, Vararg{Any}}"><code>TSCSMethods.stratify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stratify(stratfunc::Function, args...; kwargs...)</code></pre><p>Apply a stratification function, its arguments, to apply the stratification, calculate the stratified grandbalances, the treated observations in each group, and return the updated model with plot labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/stratification.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.stratifyinputs-Tuple{Any, Any, Any}" href="#TSCSMethods.stratifyinputs-Tuple{Any, Any, Any}"><code>TSCSMethods.stratifyinputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    stratifyinputs(X, s, strata)</code></pre><p>Stratify the output from processunits().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_setup.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.treatedinfo-Tuple{Any, Any, Any}" href="#TSCSMethods.treatedinfo-Tuple{Any, Any, Any}"><code>TSCSMethods.treatedinfo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function treatedinfo(
  model, variables, dat;
)</code></pre><p>Gives variable values for treated observations present in the model, for the chosen set of variables. Order is the same as model.observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/model_utilities.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.treatednums!-Tuple{Any}" href="#TSCSMethods.treatednums!-Tuple{Any}"><code>TSCSMethods.treatednums!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>assign treatment numbers in each category</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/stratification.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.trim_model-Tuple{Any}" href="#TSCSMethods.trim_model-Tuple{Any}"><code>TSCSMethods.trim_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trim_model(model)</code></pre><p>Remove treated observations that do not have any valid matches. This copies!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/retrieve_matches_utilities.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.unitcounts-Tuple{Any}" href="#TSCSMethods.unitcounts-Tuple{Any}"><code>TSCSMethods.unitcounts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitcounts(m)</code></pre><p>count the total number of treated and the number of matched units for each F.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/information.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.unitstore!-NTuple{13, Any}" href="#TSCSMethods.unitstore!-NTuple{13, Any}"><code>TSCSMethods.unitstore!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Use the mu matrix to generate vectors of weighted outcomes and unit information, as a preprocessing step for estimation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/estimation/estimation_setup.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.validate_dgp-Tuple{DataFrames.DataFrame, Float64}" href="#TSCSMethods.validate_dgp-Tuple{DataFrames.DataFrame, Float64}"><code>TSCSMethods.validate_dgp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">validate_dgp(data::DataFrame, true_att::Float64)</code></pre><p>Validate that the data generating process is working correctly. This is a helper function for debugging DGPs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/example_data.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.variable_filter-Tuple{Any, Any, Any}" href="#TSCSMethods.variable_filter-Tuple{Any, Any, Any}"><code>TSCSMethods.variable_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variable_filter(
  model, variable, dat;
  mn = nothing, mx = nothing
)</code></pre><p>Remove treated observations according to some variable values. The filtered out treated observations will still left as treated in the data, and will not be allowed to be control units for matching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/model_utilities.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.variablestrat-Tuple{CIC, Any, Any}" href="#TSCSMethods.variablestrat-Tuple{CIC, Any, Any}"><code>TSCSMethods.variablestrat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generic function to stratify on a covariate present in the dataframe.</p><p>Assumes that matching, balancing, and meanbalancing has ocurred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/advanced/stratification.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.whentreated-Tuple{Int64, VeryAbstractCICModel}" href="#TSCSMethods.whentreated-Tuple{Int64, VeryAbstractCICModel}"><code>TSCSMethods.whentreated</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">whentreated(unit_id::Int, model::VeryAbstractCICModel)</code></pre><p>Find when a specific unit received treatment.</p><p><strong>Arguments</strong></p><ul><li><code>unit_id</code>: ID of the unit to look up  </li><li><code>model</code>: Fitted TSCSMethods model</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Int, Int}}</code>: Treatment events for this unit as (treatment<em>time, unit</em>id)</li><li><code>&quot;Unit not found&quot;</code>: If unit was never treated</li></ul><p><strong>Description</strong></p><p>Searches through all treatment observations to find when (if ever) a specific unit received treatment. Returns all treatment events for units that may have multiple treatments over time.</p><p>This function is useful for:</p><ul><li>Verifying treatment timing for specific units</li><li>Checking if a unit received treatment multiple times</li><li>Debugging treatment assignment issues</li><li>Understanding the treatment history of particular units</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Check when unit 1001 was treated
treatment_events = whentreated(1001, model)

if treatment_events isa String
    println(&quot;Unit 1001 was never treated&quot;)
else
    treatment_times = [event[1] for event in treatment_events]
    println(&quot;Unit 1001 treated at times: $treatment_times&quot;)
    
    if length(treatment_events) &gt; 1
        println(&quot;Note: Unit had multiple treatments!&quot;)
    end
end

# Check multiple units
for unit_id in [1001, 1002, 1003]
    events = whentreated(unit_id, model)
    if events isa String
        println(&quot;Unit $unit_id: never treated&quot;)
    else
        println(&quot;Unit $unit_id: treated $(length(events)) times&quot;)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/utilities/information.jl#L126-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TSCSMethods.window_distances!-NTuple{13, Any}" href="#TSCSMethods.window_distances!-NTuple{13, Any}"><code>TSCSMethods.window_distances!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">window_distances!(distances, dtots, accums, valideligible_matchescols, validunits, tt, Σinvdict, treated_covariate_rows, lag_times, tg, fmin, Lmin, Lmax; sliding = false)</code></pre><p>Assign distance calculations for temporal matching windows.</p><p><strong>Arguments</strong></p><ul><li><code>distances</code>: Output matrix to store computed distances</li><li><code>dtots</code>: Pre-allocated arrays for distance calculations per covariate</li><li><code>accums</code>: Accumulator arrays for counting valid observations</li><li><code>valideligible_matchescols</code>: Valid match columns for each potential match</li><li><code>validunits</code>: Unit identifiers for valid matches</li><li><code>tt</code>: Treatment time indicator</li><li><code>Σinvdict</code>: Dictionary of inverse covariance matrices by time period</li><li><code>treated_covariate_rows</code>: Treated unit covariate rows over time</li><li><code>lag_times</code>: Time periods for the treated unit</li><li><code>tg</code>: Treatment group data structure</li><li><code>fmin</code>: Minimum relative time offset for matching window</li><li><code>Lmin</code>: Minimum absolute time for matching</li><li><code>Lmax</code>: Maximum absolute time for matching</li><li><code>sliding</code>: Whether to use sliding windows (default: false, not implemented)</li></ul><p><strong>Algorithm</strong></p><ol><li><strong>Window Definition</strong>: Create temporal matching windows based on treatment timing</li><li><strong>Distance Computation</strong>: For each valid match and time window:<ul><li>Extract control unit data for the same time periods</li><li>Calculate Mahalanobis and covariate-specific distances using <code>alldistances!</code></li><li>Average distances over the matching window using <code>average_distances!</code></li></ul></li><li><strong>Storage</strong>: Store final averaged distances in the <code>distances</code> matrix</li></ol><p><strong>Mathematical Foundation</strong></p><p>Implements the temporal windowing approach from Feltham et al. (2023), where matches are formed based on distance averages over specified pre-treatment periods.</p><p><strong>Performance Notes</strong></p><ul><li><strong>Complexity</strong>: O(n<em>matches × window</em>size × n_covariates)</li><li><strong>Threading</strong>: Called within threaded loops, uses thread-local storage</li><li><strong>Memory</strong>: Reuses pre-allocated arrays to minimize allocations</li></ul><p><strong>Note</strong></p><p>Currently only supports fixed windows. Sliding window implementation would allow the matching window to vary by treatment time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/human-nature-lab/TSCSMethods.jl/blob/97a2a14f0b31e869fe09b5638bf851cb54929f37/src/matching/distancing.jl#L363-L404">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../methodology/">« Methodology</a><a class="docs-footer-nextpage" href="../validation/">Validation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 21:40">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
