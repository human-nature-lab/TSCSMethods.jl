var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"This page provides comprehensive documentation for all TSCSMethods.jl functions and types.","category":"page"},{"location":"api.html#Complete-Function-and-Type-Reference","page":"API Reference","title":"Complete Function and Type Reference","text":"","category":"section"},{"location":"api.html#TSCSMethods.CIC","page":"API Reference","title":"TSCSMethods.CIC","text":"CIC <: AbstractCICModel\n\nMain model type for causal inference with time-series cross-sectional data.\n\nContains all information needed for matching, balancing, and estimation in TSCS designs. Created by makemodel() and used throughout the analysis workflow.\n\nFields\n\ntitle::String: Model title for identification\nid::Symbol: Column name for unit identifier \nt::Symbol: Column name for time variable\noutcome::Union{Symbol,Vector{Symbol}}: Outcome variable(s)\ntreatment::Symbol: Treatment variable (binary 0/1)\ncovariates::Vector{Symbol}: Covariates used for matching\ntimevary::Dict{Symbol, Bool}: Whether each covariate is time-varying\nreference::Int: Reference time period (default: -1)\nF::UnitRange{Int}: Post-treatment periods for estimation\nL::UnitRange{Int}: Pre-treatment periods for matching (negative values)\nobservations::Vector{Tuple{Int, Int}}: Treated observations (time, unit)\nids::Vector{Int}: All unit identifiers\nmatches::Vector{Tob}: Matching results for each treated observation\nmeanbalances::DataFrame: Covariate balance statistics\ngrandbalances::Dict: Overall balance measures\niterations::Int: Bootstrap iterations (default: 500)\nresults::DataFrame: Treatment effect estimates\ntreatednum::Int: Number of treated observations\nestimator::String: Estimator type (default: \"ATT\")\n\nExamples\n\nusing TSCSMethods, DataFrames\n\ndata = example_data()\nmodel = makemodel(data, :day, :fips, :gub, :death_rte, \n                 [:pop_dens], Dict(:pop_dens => false),\n                 1:5, -10:-1)\n\n\n\n\n\n","category":"type"},{"location":"api.html#TSCSMethods.CICStratified","page":"API Reference","title":"TSCSMethods.CICStratified","text":"CICStratified <: AbstractCICModelStratified\n\nStratified model type for causal inference with time-series cross-sectional data.\n\nExtends the basic CIC model to handle stratified analysis where matching and estimation are performed separately within subgroups defined by a stratifying variable.\n\nFields\n\ntitle::String: Model title for identification\nid::Symbol: Column name for unit identifier\nt::Symbol: Column name for time variable  \noutcome::Union{Symbol,Vector{Symbol}}: Outcome variable(s)\ntreatment::Symbol: Treatment variable (binary 0/1)\ncovariates::Vector{Symbol}: Covariates used for matching\ntimevary::Dict{Symbol, Bool}: Whether each covariate is time-varying\nstratifier::Symbol: Variable used for stratification\nstrata::Vector{Int}: Values of stratifying variable\nreference::Int: Reference time period (default: -1)  \nF::UnitRange{Int}: Post-treatment periods for estimation\nL::UnitRange{Int}: Pre-treatment periods for matching (negative values)\nobservations::Vector{Tuple{Int, Int}}: Treated observations (time, unit)\nids::Vector{Int}: All unit identifiers\nmatches::Vector{Tob}: Matching results for each treated observation\nmeanbalances::DataFrame: Covariate balance statistics by stratum\ngrandbalances::Dict: Overall balance measures by stratum\niterations::Int: Bootstrap iterations (default: 500)\nresults::DataFrame: Treatment effect estimates by stratum\ntreatednum::Dict{Int64, Int64}: Number of treated observations per stratum\nestimator::String: Estimator type (default: \"ATT\")\nlabels::Dict{Int64, String}: Human-readable labels for strata\n\nExamples\n\n# Create stratified model\nmodel = makemodel(data, :day, :fips, :gub, :death_rte,\n                 [:pop_dens], Dict(:pop_dens => false),\n                 1:5, -10:-1)\nstrat_model = stratify(model, data, :region)\n\n\n\n\n\n","category":"type"},{"location":"api.html#TSCSMethods.Fblock","page":"API Reference","title":"TSCSMethods.Fblock","text":"    Fblock\n\nHolds the relevant information for bootstrapping and estimation, for a specific f in the outcome window (an f in a stratum when the model is stratified).\n\n\n\n\n\n","category":"type"},{"location":"api.html#TSCSMethods._estimate!-Tuple{Any, Any, Any, Vector{Symbol}, Vararg{Any, 8}}","page":"API Reference","title":"TSCSMethods._estimate!","text":"version for multiple outcomes\n\ndoes not include p-values, bayesfactor\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods._makegroupindices-NTuple{13, Any}","page":"API Reference","title":"TSCSMethods._makegroupindices","text":"version with exposure\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.alldistances!-NTuple{5, Any}","page":"API Reference","title":"TSCSMethods.alldistances!","text":"N.B. if any of the input xr or yr (the covariate values for the treated and match at some day in the covariate matching window) are missing, then the  maha distance is missing.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.allocate_meanbalances!-Tuple{Any}","page":"API Reference","title":"TSCSMethods.allocate_meanbalances!","text":"allocate_meanbalances!(model)\n\nPrepare the meanbalances DataFrame for a model. Meanbalances has number of rows == observations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.att!-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.att!","text":"    att!(atts, tcounts, fblocks)\n\nCalculate the att for each f, for a the set of treated units and matches contained in the fblocks.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.autobalance-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.autobalance","text":"autobalance(\n  model, dat;\n  refinementnum = 5,\n  calmin = 0.08, step = 0.05,\n  initial_bals = nothing\n)\n\nAutomatically balance via a simple algorithm. Start with initial caliper of 1.0, and subtract step whenever the grand mean balance threshold (0.1) is not met.\n\ninitial_bals is specified, work downward from the initial specified caliper for one or more selected variables. Unspecified variables start at a caliper of 1.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.balance!-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.balance!","text":"balance!(model::VeryAbstractCICModel, dat::DataFrame) -> VeryAbstractCICModel\n\nPerform covariate balancing on a matched model to ensure treated and control units are comparable on observed characteristics.\n\nArguments\n\nmodel::VeryAbstractCICModel: A CIC model that has been matched (using match!)\ndat::DataFrame: Input data containing all model variables\n\nReturns\n\nThe input model with updated balance statistics\n\nDescription\n\nThis function performs two types of balancing:\n\nMean balancing: Computes balance statistics for each covariate across treatment periods\nGrand balancing: Aggregates balance statistics across the entire model\n\nBalancing assesses how well the matching procedure achieved covariate balance between treated and control groups. Poor balance may indicate the need for refinement via calipers or other restrictions.\n\nThrows\n\nArgumentError: If input data is empty\nErrorException: If balance calculations fail\n\nExamples\n\n# After constructing and matching a model\nmodel = makemodel(data, :time, :id, :treatment, :outcome, \n                 [:covar1, :covar2], timevary_dict, F_periods, L_periods)\nmatch!(model, data)\n\n# Perform balancing\nbalance!(model, data)\n\n# Check balance results\ncheckbalances(model, data)\n\nSee Also\n\ncheckbalances: Assess balance quality\nautobalance: Automatic balance improvement\nmatch!: Matching procedure that should precede balancing\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.bootinfo!-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.bootinfo!","text":"bootinfo!(res, oc, boots; qtiles = [0.025, 0.5, 0.975])\n\nFormat the bootstrap matrix into the results dataframe. Assumes that att() has already been added to res.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.bootinfo!-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.bootinfo!","text":"bootinfo!(res, boots; qtiles = [0.025, 0.5, 0.975])\n\nFormat the bootstrap matrix into the results dataframe. Assumes that att() has already been added to res.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.bootstrap!-NTuple{6, Any}","page":"API Reference","title":"TSCSMethods.bootstrap!","text":"    bootstrap!(boots, tcountmat, fblocks, ids, treatdex, iterations)\n\nPerform bootstrapping of the att for each f in the outcome window. Does so for the given set of treated units and matches contained in the fblocks.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.calculate_sample_Σs!-Tuple{Any, Any, Any, Any, Bool}","page":"API Reference","title":"TSCSMethods.calculate_sample_Σs!","text":"inverted covariance matrix for mahalanobis distance (all units at t)\n\ninverted sqrt(vars) for balance score calculations (treated units at t)\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.caliper-Tuple{CIC, Any, Any}","page":"API Reference","title":"TSCSMethods.caliper","text":"caliper(\n    model::CIC, \n    acaliper::Dict{Symbol, Float64}, \n    dat::DataFrame; \n    dobalance::Bool = true\n) -> CaliperCIC\n\nApply caliper restrictions to a CIC model by excluding matches beyond specified distance thresholds.\n\nArguments\n\nmodel::CIC: A matched CIC model\nacaliper::Dict{Symbol, Float64}: Dictionary mapping covariates to maximum allowed distances\ndat::DataFrame: Input data containing all model variables\ndobalance::Bool: Whether to perform balancing on the calipered model (default: true)\n\nReturns\n\nCaliperCIC: A calipered version of the input model with restricted matches\n\nDescription\n\nCaliper restrictions improve match quality by excluding matches where the distance on specified covariates exceeds the given thresholds. This helps ensure that matched units are similar on the most important dimensions, potentially improving balance and reducing bias.\n\nExamples\n\n# After matching a model\nmodel = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)\nmatch!(model, data)\n\n# Apply calipers - exclude matches with distance > 0.25 on covar1 or > 0.5 on covar2\ncaliper_specs = Dict(:covar1 => 0.25, :covar2 => 0.5)\ncalipered_model = caliper(model, caliper_specs, data)\n\n# Apply calipers without automatic balancing\ncalipered_model = caliper(model, caliper_specs, data; dobalance = false)\n\nNotes\n\nStricter calipers improve match quality but reduce the number of matches\nUse autobalance to automatically determine appropriate caliper values\n\nSee Also\n\nrefine: Alternative approach using match ranking\nautobalance: Automatic caliper selection\nmatch!: Initial matching procedure\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.checkbalances-Tuple{AbstractCICModel}","page":"API Reference","title":"TSCSMethods.checkbalances","text":"checkbalances(\n  m::Dict{Symbol, Union{Float64, Vector{Float64}}};\n  threshold = 0.1, stratareduce = true\n)\n\nSimply check whether the grand means are above the std. balance threshold. Returns a Bool for each covariate. If Stratareduce is true, then the strata balances will be agggregated to the covariate level, such that a violation in any caliper triggers a violation in the aggregated output.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.checksample-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.checksample","text":"not stratified\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.combostrat-Tuple{Any, Vector{Symbol}, Any}","page":"API Reference","title":"TSCSMethods.combostrat","text":"combostrat(model, dat, vars::Vector{Symbol}; varslabs = nothing)\n\nStratify based on the combinations of one or more variables that exist in the data. Strata are formed directly from the variable values.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.countmemb-Tuple{Any, Int64}","page":"API Reference","title":"TSCSMethods.countmemb","text":"faster version of countmap, use when length is known\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.customstrat-Tuple{Any, Any, Dict{Tuple{Int64, Int64}, Int64}}","page":"API Reference","title":"TSCSMethods.customstrat","text":"customstrat!(\n  cc,\n  stratdict::Union{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}\n)\n\nStratify based on the values of some input dictionary, specifying strata for each (t, id) or each (id) for a stratification that varies only by unit.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.default_treatmentcategories-Tuple{Any}","page":"API Reference","title":"TSCSMethods.default_treatmentcategories","text":"default_treatmentcategories(x)\n\n(For use as input to match!) Default treatment history categories. We look at total count in the pre-treatment crossover period for both the treated unit and its (potential) match. If the totals, for each, in the same period fall into the same cateory, we allow the match.\n\nHere the categories are either not treated, or treated. Ths works for single treatments, and prevents matches from being treated at all during the pretreatment crossover window.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.economic_data-Tuple{}","page":"API Reference","title":"TSCSMethods.economic_data","text":"economic_data(; n_units = 40, n_days = 90, seed = 789)\n\nGenerate synthetic economic shock dataset for demonstration.\n\nArguments\n\nn_units::Int: Number of units (countries/regions) to generate (default: 40)\nn_days::Int: Number of time periods to generate (default: 90)\nseed::Int: Random seed for reproducibility (default: 789)\n\nReturns\n\nDataFrame: Synthetic panel data with economic shock theme\n\nDescription\n\nSimulates an economic analysis where units experience economic shocks (e.g., natural disasters, financial crises) at different times. Includes realistic economic indicators and shock effects.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.eligibility-Tuple{Any}","page":"API Reference","title":"TSCSMethods.eligibility","text":"eligibility(model)\n\n\"eligibility\" for units, over all treated units => num. times a particular unit is eligible to be a match, for each F in the outcome window.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.estimate!-Tuple{AbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.estimate!","text":"estimate!(\n    ccr::AbstractCICModel, dat;\n    iterations = nothing,\n    percentiles = [0.025, 0.5, 0.975],\n    overallestimate = false,\n    bayesfactor = true\n)\n\nPerform ATT estimation, with bootstrapped CIs.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.estimate!-Tuple{AbstractCICModelStratified, Any}","page":"API Reference","title":"TSCSMethods.estimate!","text":"estimate!(ccr::AbstractCICModelStratified, dat; iterations = nothing)\n\nPerform ATT stratified estimation, with bootstrapped CIs.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.example_data-Tuple{}","page":"API Reference","title":"TSCSMethods.example_data","text":"example_data(; n_units = 100, n_days = 90, seed = 123)\n\nGenerate synthetic example data for testing and demonstration purposes.\n\nArguments\n\nn_units::Int: Number of units (counties/regions) to generate (default: 100)\nn_days::Int: Number of time periods to generate (default: 90)\nseed::Int: Random seed for reproducibility (default: 123)\n\nReturns\n\nDataFrame: Synthetic panel data with columns: date, fips, popdens, cumuldeathrate, deathrte, gub, day\n\nDescription\n\nCreates synthetic panel data mimicking the structure used in Feltham et al. (2023):\n\nUnits represent counties with FIPS codes\nTreatment (gubernatorial elections) affects first 20% of units\nRealistic population density and outcome variables with trends\nIncludes both time-invariant (popdens) and time-varying (cumuldeath_rate) covariates\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.executesample!-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.executesample!","text":"not stratified\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.filterunits!-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.filterunits!","text":"filterunits!(m, omap)\n\nRemove treated units and matches that do not have values defined in the outcome window. This could be modified to account for missingness easily. This should probably be integrated into the match! procedure. (keep separate for now). (Updates ranks as well.)\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.fpossible!-NTuple{7, Any}","page":"API Reference","title":"TSCSMethods.fpossible!","text":"check possibility of the match for each f\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.fpossible!-NTuple{9, Any}","page":"API Reference","title":"TSCSMethods.fpossible!","text":"check possibility of the match for each f\n\nversion with exposure\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.fpossible_mis!-NTuple{11, Any}","page":"API Reference","title":"TSCSMethods.fpossible_mis!","text":"check possibility of the match for each f\n\nversion with exposure\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.fpossible_mis!-NTuple{9, Any}","page":"API Reference","title":"TSCSMethods.fpossible_mis!","text":"check possibility of the match for each f\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.getoutcomemap-NTuple{4, Any}","page":"API Reference","title":"TSCSMethods.getoutcomemap","text":"    getoutcomemap(outcome, dat, t, id)\n\nGet dictionary, from specified unit and time to outcome.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.getsample-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.getsample","text":"not stratified\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.grandbalance!-Tuple{AbstractCICModelStratified}","page":"API Reference","title":"TSCSMethods.grandbalance!","text":"grandbalance!(model::AbstractCICModelStratified)\n\nCalculate the overall mean covariate balance for a model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.grandbalance!-Tuple{AbstractCICModel}","page":"API Reference","title":"TSCSMethods.grandbalance!","text":"grandbalance!(model::AbstractCICModel)\n\nCalculate the overall mean covariate balance for a model.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.impute_results-NTuple{4, Any}","page":"API Reference","title":"TSCSMethods.impute_results","text":"Impute Y(0).\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.make_groupindices-NTuple{7, Any}","page":"API Reference","title":"TSCSMethods.make_groupindices","text":"make_groupindices(tvec, treatvec, idvec, uid, fmax, Lmin, cdat)\n\nGet partially overlapping values for treated observations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.makefblocks-NTuple{5, Any}","page":"API Reference","title":"TSCSMethods.makefblocks","text":"    makefblocks(subTus, subMus, subWos, subWrs, subFs)\n\nPopulate a set of fblocks to estimate and bootstrap the ATT.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.makemodel-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol, Union{Symbol, Vector{Symbol}}, Vector{Symbol}, Dict{Symbol, Bool}, UnitRange{Int64}, UnitRange{Int64}}","page":"API Reference","title":"TSCSMethods.makemodel","text":"makemodel(\n    dat::DataFrame, \n    t::Symbol, \n    id::Symbol, \n    treatment::Symbol, \n    outcome::Union{Symbol, Vector{Symbol}},\n    covariates::Vector{Symbol}, \n    timevary::Dict{Symbol, Bool},\n    F::UnitRange{Int}, \n    L::UnitRange{Int};\n    title::String = \"model\",\n    estimator::String = \"ATT\"\n) -> CIC\n\nConstruct a CIC (Changes-in-Changes) model for causal inference analysis.\n\nArguments\n\ndat::DataFrame: Input data containing all required variables\nt::Symbol: Column name for time variable\nid::Symbol: Column name for unit identifier\ntreatment::Symbol: Column name for treatment variable (0/1 coding expected)\noutcome::Union{Symbol, Vector{Symbol}}: Column name(s) for outcome variable(s)\ncovariates::Vector{Symbol}: Vector of column names for matching covariates\ntimevary::Dict{Symbol, Bool}: Dictionary mapping each covariate to whether it's time-varying\nF::UnitRange{Int}: Time periods for treatment effect estimation (post-treatment)\nL::UnitRange{Int}: Time periods for pre-treatment matching window\ntitle::String: Optional title for the model (default: \"model\")\nestimator::String: Estimator type (default: \"ATT\" for Average Treatment Effect on Treated)\n\nReturns\n\nCIC: A constructed CIC model ready for matching, balancing, and estimation\n\nThrows\n\nArgumentError: If input data is empty, required columns are missing, or parameters are invalid\n\nExamples\n\nusing TSCSMethods, DataFrames\n\n# Create sample data\ndata = DataFrame(\n    time = repeat(1:100, 50),\n    unit_id = repeat(1:50, inner=100),\n    treated = repeat([fill(1, 10); fill(0, 40)], inner=100),\n    outcome = randn(5000),\n    covar1 = randn(5000),\n    covar2 = randn(5000)\n)\n\n# Construct model\nmodel = makemodel(\n    data, :time, :unit_id, :treated, :outcome,\n    [:covar1, :covar2],\n    Dict(:covar1 => false, :covar2 => true),\n    51:60, 40:49  # F and L periods\n)\n\nReferences\n\nBased on the methodology from Imai, Kim, and Wang (2021) for matching methods  with time-series cross-sectional data.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.match!-Tuple{AbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.match!","text":"match!(\n  model::AbstractCICModel, dat::DataFrame;\n  treatcat = nothing, exposure = nothing\n)\n\nPerform matching for treatment events, using Mahalanobis distance matching. Additionally, calculate standardized Euclidean distances for the individual covariates are specified.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any, Any, Any}","page":"API Reference","title":"TSCSMethods.meanbalance!","text":"meanbalance!(model, dat, tg, rg)\n\nCalculate the mean balances, for each treated observation from the full set of balances. This will limit the calculations to include those present in model.matches, e.g. in case a caliper has been applied.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.meanbalance!-Tuple{VeryAbstractCICModel, Any}","page":"API Reference","title":"TSCSMethods.meanbalance!","text":"meanbalance!(model)\n\nCalculate the mean balances, for each treated observation from the full set of balances. This will limit the calculations to include those present in model.matches, e.g. in case a caliper has been applied.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.name_model-Tuple{VeryAbstractCICModel}","page":"API Reference","title":"TSCSMethods.name_model","text":"name_model(model::VeryAbstractCICModel)\n\nGenerate the filename for a set of models.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.observationweights-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.observationweights","text":"treated observation weights\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.obsinfo-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.obsinfo","text":"obsinfo(\n  rcinfo, dat, vars;\n  fullmodobs = nothing,\n  t = :running, id = :fips\n)\n\nGet the requested info for the treated units. If the var is timevarying, it will get it from the time of the treatment event.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.policy_data-Tuple{}","page":"API Reference","title":"TSCSMethods.policy_data","text":"policy_data(; n_units = 30, n_days = 120, seed = 456)\n\nGenerate synthetic policy intervention dataset for demonstration.\n\nArguments\n\nn_units::Int: Number of units (states/regions) to generate (default: 30)\nn_days::Int: Number of time periods to generate (default: 120) \nseed::Int: Random seed for reproducibility (default: 456)\n\nReturns\n\nDataFrame: Synthetic panel data with policy intervention theme\n\nDescription\n\nSimulates a policy intervention study where different units adopt policies at different times. Includes multiple time-varying covariates and realistic policy effect patterns.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.quick_att-Tuple{Any}","page":"API Reference","title":"TSCSMethods.quick_att","text":"quickatt(matchseries;     outcomes = [:deathrte, :case_rte, :deaths, :cases],     F = 10:40,     ttt = false,     tm1 = 30 )\n\nQuickly calculate the att for specified outcomes based on the output of the  matchprocess(). Does not calculate confidence intervals.\n\nCalculates both the individual-level unit effects, and the average effects.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.refine-Tuple{CIC, Any}","page":"API Reference","title":"TSCSMethods.refine","text":"refine(\n    model::CIC, \n    dat::DataFrame;\n    refinementnum::Int = 5, \n    dobalance::Bool = true,\n    doestimate::Bool = true\n) -> RefinedCIC\n\nRefine a CIC model by keeping only the best refinementnum matches for each treated unit.\n\nArguments\n\nmodel::CIC: A matched CIC model\ndat::DataFrame: Input data containing all model variables\nrefinementnum::Int: Number of best matches to retain per treated unit (default: 5)\ndobalance::Bool: Whether to perform balancing on the refined model (default: true)\ndoestimate::Bool: Whether to perform estimation on the refined model (default: true)\n\nReturns\n\nRefinedCIC: A refined version of the input model with reduced matches\n\nDescription\n\nRefinement improves match quality by keeping only the closest matches for each treated unit, based on the distance metrics computed during the matching stage. This typically improves covariate balance and estimation precision at the cost of statistical power.\n\nExamples\n\n# After matching a model\nmodel = makemodel(data, :time, :id, :treatment, :outcome, covariates, timevary, F, L)\nmatch!(model, data)\n\n# Refine to top 3 matches per treated unit\nrefined_model = refine(model, data; refinementnum = 3)\n\n# Refine without automatic balancing and estimation\nrefined_model = refine(model, data; refinementnum = 5, dobalance = false, doestimate = false)\n\nSee Also\n\ncaliper: Alternative approach using distance thresholds\nmatch!: Initial matching procedure\nbalance!: Balance assessment\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.showmatches-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.showmatches","text":"showmatches(model, treatob)\n\nShow the ranked (best to worst) eligible matches to a chosen treated observation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.std_treated-Tuple{VeryAbstractCICModel, DataFrames.DataFrame}","page":"API Reference","title":"TSCSMethods.std_treated","text":"gives (1 / (std of treated units)) for each l in the matching period\n\noutputs dict[t-l, covariate] where t-l is l days prior to the treatment\n\n(adjust this for f, in sliding window F-defined match period case, which is the case...)\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.stratify-Tuple{Function, CIC, Vararg{Any}}","page":"API Reference","title":"TSCSMethods.stratify","text":"stratify(stratfunc::Function, args...; kwargs...)\n\nApply a stratification function, its arguments, to apply the stratification, calculate the stratified grandbalances, the treated observations in each group, and return the updated model with plot labels.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.stratifyinputs-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.stratifyinputs","text":"    stratifyinputs(X, s, strata)\n\nStratify the output from processunits().\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.treatedinfo-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.treatedinfo","text":"function treatedinfo(\n  model, variables, dat;\n)\n\nGives variable values for treated observations present in the model, for the chosen set of variables. Order is the same as model.observations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.treatednums!-Tuple{Any}","page":"API Reference","title":"TSCSMethods.treatednums!","text":"assign treatment numbers in each category\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.trim_model-Tuple{Any}","page":"API Reference","title":"TSCSMethods.trim_model","text":"trim_model(model)\n\nRemove treated observations that do not have any valid matches. This copies!\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.unitcounts-Tuple{Any}","page":"API Reference","title":"TSCSMethods.unitcounts","text":"unitcounts(m)\n\ncount the total number of treated and the number of matched units for each F.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.unitstore!-NTuple{13, Any}","page":"API Reference","title":"TSCSMethods.unitstore!","text":"Use the mu matrix to generate vectors of weighted outcomes and unit information, as a preprocessing step for estimation.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.variable_filter-Tuple{Any, Any, Any}","page":"API Reference","title":"TSCSMethods.variable_filter","text":"variable_filter(\n  model, variable, dat;\n  mn = nothing, mx = nothing\n)\n\nRemove treated observations according to some variable values. The filtered out treated observations will still left as treated in the data, and will not be allowed to be control units for matching.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.variablestrat-Tuple{CIC, Any, Any}","page":"API Reference","title":"TSCSMethods.variablestrat","text":"Generic function to stratify on a covariate present in the dataframe.\n\nAssumes that matching, balancing, and meanbalancing has ocurred.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.whentreated-Tuple{Any, Any}","page":"API Reference","title":"TSCSMethods.whentreated","text":"whentreated(fips, model)\n\nInput a unit id, and see when (if) a treatment occured.\n\n\n\n\n\n","category":"method"},{"location":"api.html#TSCSMethods.window_distances!-NTuple{13, Any}","page":"API Reference","title":"TSCSMethods.window_distances!","text":"Assign distances for each window. This could be massively simplified for a non-sliding window.\n\n\n\n\n\n","category":"method"},{"location":"index.html#TSCSMethods.jl","page":"Home","title":"TSCSMethods.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Matching methods for causal inference with time-series cross-sectional data","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"TSCSMethods.jl implements the matching methodology developed in Feltham et al. (2023), which is based on Imai et al. (2021) for causal inference with time-series cross-sectional (TSCS) data.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This package was initially developed for and used in the analyses of Feltham et al. (2023).","category":"page"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using TSCSMethods, DataFrames\n\n# Generate example data\ndat = example_data(n_units=50, n_days=60)\n\n# Create model\nmodel = makemodel(\n    dat, :day, :fips, :gub, :death_rte,\n    [:pop_dens], Dict(:pop_dens => false),\n    5:10,    # F: post-treatment periods  \n    -15:-10  # L: pre-treatment periods\n)\n\n# Run complete workflow\nmatch!(model, dat)      # Find matched control units\nbalance!(model, dat)    # Calculate covariate balances  \nestimate!(model, dat)   # Estimate treatment effects\n\n# View results\nmodel.results","category":"page"},{"location":"index.html#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Staggered Treatment Design: Handles units treated at different times\nMatching & Balancing: Find comparable control units and assess covariate balance\nBootstrap Inference: Robust standard errors and confidence intervals\nTime-Series Structure: Explicitly accounts for temporal correlation\nMultiple Outcomes: Support for analyzing multiple dependent variables","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/emfeltham/TSCSMethods.jl\")","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use TSCSMethods.jl in your research, please cite:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@article{feltham_mass_2023,\n  title={Mass gatherings for political expression had no discernible association with the local course of the COVID-19 pandemic in the USA in 2020 and 2021},\n  author={Feltham, Eric and Forastiere, Laura and Alexander, Marcus and Christakis, Nicholas A},\n  journal={Nature Human Behaviour},\n  year={2023},\n  publisher={Nature Publishing Group}\n}\n\n@misc{feltham_tscsmethods_2023,\n  title={TSCSMethods.jl: Matching methods for causal inference with time-series cross-sectional data},\n  author={Feltham, Eric Martin},\n  year={2023},\n  url={https://github.com/emfeltham/TSCSMethods.jl}\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Please also cite the foundational methodology:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@article{imai_matching_2021,\n  title={Matching Methods for Causal Inference with Time-Series Cross-Sectional Data},\n  author={Imai, Kosuke and Kim, In Song and Wang, Erik H},\n  journal={American Journal of Political Science},\n  year={2021},\n  publisher={Wiley Online Library}\n}","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Imai, K., Kim, I. S., & Wang, E. H. (2021). Matching Methods for Causal Inference with Time-Series Cross-Sectional Data. American Journal of Political Science.\nFeltham, E., Forastiere, L., Alexander, M., & Christakis, N. A. (2023). Mass gatherings for political expression had no discernible association with the local course of the COVID-19 pandemic in the USA in 2020 and 2021. Nature Human Behaviour.\nKim, I. S., Ruah, A., Wang, E., & Imai, K. (2020). Insongkim/PanelMatch [R, C]. https://github.com/insongkim/PanelMatch (Original work published 2018)","category":"page"},{"location":"methodology.html#Methodology","page":"Methodology","title":"Methodology","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"This page explains the statistical methodology implemented in TSCSMethods.jl.","category":"page"},{"location":"methodology.html#Overview","page":"Methodology","title":"Overview","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"TSCSMethod.jl implements the matching approach for time-series cross-sectional (TSCS) data developed by Imai et al. (2021). This method addresses key challenges in causal inference with panel data:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Selection bias: Units self-select into treatment\nTime-varying confounding: Confounders change over time\nTemporal correlation: Outcomes are correlated within units over time","category":"page"},{"location":"methodology.html#The-Matching-Framework","page":"Methodology","title":"The Matching Framework","text":"","category":"section"},{"location":"methodology.html#Problem-Setup","page":"Methodology","title":"Problem Setup","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Consider panel data with:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Units: i = 1  N (e.g., counties, countries)\nTime periods: t = 1  T\nTreatment: D_it in 0 1 \nOutcome: Y_it\nCovariates: X_it","category":"page"},{"location":"methodology.html#Staggered-Treatment-Design","page":"Methodology","title":"Staggered Treatment Design","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"TSCSMethods.jl handles staggered adoption where units receive treatment at different times:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Unit i receives treatment at time tau_i (the specific day of the event)\nD_it = 1\nif t = tau_i, 0 otherwise (treatment occurs only on event day)\nFocus on event studies: effects relative to treatment timing\nSupports any discrete events occurring on specific dates","category":"page"},{"location":"methodology.html#Matching-Algorithm","page":"Methodology","title":"Matching Algorithm","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"For each treated unit i at time tau_i:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Define matching window: Pre-treatment periods L = l_1  l_L (negative values)\nFind similar controls: Units j with similar X_jtau_i+l for l in L\nCalculate distances: d(ij) = sum_l in L w_l X_itau_i+l - X_jtau_i+l\nSelect matches: Closest K control units for each treated unit","category":"page"},{"location":"methodology.html#Balancing","page":"Methodology","title":"Balancing","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Assess matching quality by comparing covariate distributions:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"textBalance_lk = frac1n_1 sum_i in textTreated X_itau_i+l - frac1n_0 sum_j in textControls X_jtau_i+l","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Good matches have small balance statistics.","category":"page"},{"location":"methodology.html#Treatment-Effect-Estimation","page":"Methodology","title":"Treatment Effect Estimation","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Estimate Average Treatment Effect on Treated (ATT) for post-treatment periods f in F:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"hattau_f = frac1textTreated sum_i in textTreated left Y_itau_i+f - frac1M_i sum_j in M_i Y_jtau_i+f right","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"where M_i is the set of matched controls for unit i.","category":"page"},{"location":"methodology.html#Crossover-Windows-and-Treatment-History","page":"Methodology","title":"Crossover Windows and Treatment History","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"The method incorporates sophisticated treatment history matching:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Crossover window: Period examined for treatment history of potential matches\nPre-treatment crossover: Matches must have similar treatment histories before the focal treatment\nPost-treatment crossover: Control units cannot be treated during specified periods after the focal treatment\nThis prevents contamination from other events that might confound the estimates","category":"page"},{"location":"methodology.html#Bootstrap-Inference","page":"Methodology","title":"Bootstrap Inference","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Uncertainty quantification via weighted block-bootstrap:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Block resampling: Resample entire time series of units to account for within-unit temporal dependence\nWeighted procedure: Account for units being used as matches multiple times\nRe-estimation: Calculate ATT for each of 10,000 bootstrap samples\nConfidence intervals: Derived from 2.5th and 97.5th percentiles of bootstrap distribution\nBayes factors: Additional evidence quantification using bootstrap distribution parameters","category":"page"},{"location":"methodology.html#Implementation-Details","page":"Methodology","title":"Implementation Details","text":"","category":"section"},{"location":"methodology.html#Time-Period-Specification","page":"Methodology","title":"Time Period Specification","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"L periods: Pre-treatment periods for matching (negative values)\nExample: L = -10:-1 uses 10 periods before treatment\nF periods: Post-treatment periods for estimation (positive values)  \nExample: F = 1:5 estimates effects 1-5 periods after treatment\nReference period: Usually -1 (period just before treatment)","category":"page"},{"location":"methodology.html#Covariate-Handling","page":"Methodology","title":"Covariate Handling","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Time-invariant: Unit characteristics that don't change over the study period\nDemographics, geography, institutional features\nAny baseline characteristics relevant to the outcome\nTime-varying: Variables that change over time during the matching window\nOutcome history, behavioral indicators, environmental conditions\nAny time-series covariates relevant to treatment assignment and outcomes\nStandardization: Covariates standardized using treated unit variance\nBalance assessment: Standardized mean differences maintained ≤ 0.1","category":"page"},{"location":"methodology.html#Distance-Metrics","page":"Methodology","title":"Distance Metrics","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Default uses Mahalanobis distance with temporal averaging:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"d(ij) = frac1L sum_l=1^L sqrt(V_it-l - V_jt-l)^T Sigma_it-l^-1 (V_it-l - V_jt-l)","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"where:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"V_it-l\nis the vector of covariates for unit i at time t-l\nSigma_it-l\nis the diagonal covariance matrix\nL = 30\ndays is the matching window length\nDistance averaged over the pre-treatment period","category":"page"},{"location":"methodology.html#Assumptions","page":"Methodology","title":"Assumptions","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"The method relies on several key assumptions:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Unconfoundedness: Y_it(0) Y_it(1) perp D_it  X_it textpast\nCommon support: Sufficient overlap in covariate distributions\nNo anticipation: Units don't change behavior before treatment\nSUTVA: No spillover effects between units","category":"page"},{"location":"methodology.html#Extensions","page":"Methodology","title":"Extensions","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"TSCSMethods.jl supports several extensions:","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Calipers: Restrict matches to units within distance threshold (balance scores ≤ 0.1)\nStratification: Separate analysis by subgroups (any categorical or binned continuous variables)\nMultiple outcomes: Analyze several dependent variables simultaneously\nRefinement: Iterative improvement of matches (up to 5 best matches per treated unit)\nSpillover effects: Account for geographic spillover (e.g., rally attendees from neighboring counties)\nMultiple treatments: Handle units with repeated treatments over time","category":"page"},{"location":"methodology.html#Spillover-Effects-Implementation","page":"Methodology","title":"Spillover Effects Implementation","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"For events with potential geographic spillover (see Feltham et al. 2023 for a detailed case):","category":"page"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Direct treatment: County hosts the event\nFirst degree: Counties adjacent to event location\nSecond degree: Counties one step away from event location  \nThird degree: Counties two steps away from event location\nSeparate ATT estimation for each exposure level","category":"page"},{"location":"methodology.html#References","page":"Methodology","title":"References","text":"","category":"section"},{"location":"methodology.html","page":"Methodology","title":"Methodology","text":"Imai, K., Kim, I. S., & Wang, E. H. (2021). Matching Methods for Causal Inference with Time-Series Cross-Sectional Data. American Journal of Political Science.\nRosenbaum, P. R., & Rubin, D. B. (1983). The central role of the propensity score in observational studies for causal effects. Biometrika, 70(1), 41-55.","category":"page"},{"location":"tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"This tutorial walks through a complete analysis using TSCSMethods.jl, explaining each step in detail.","category":"page"},{"location":"tutorial.html#Understanding-the-Data-Structure","page":"Tutorial","title":"Understanding the Data Structure","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"TSCSMethods expects staggered treatment design data where:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Units (e.g., counties, countries) are treated at specific times\nTreatment is binary (0/1) and occurs on specific dates, not continuously\nTime periods are relative to treatment: negative for pre-treatment, positive for post-treatment","category":"page"},{"location":"tutorial.html#Example-Data-Format","page":"Tutorial","title":"Example Data Format","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using TSCSMethods, DataFrames\n\n# Generate example data\ndat = example_data(n_units=20, n_days=50, seed=123)\nfirst(dat, 10)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Key columns:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"fips: Unit identifier\nday: Time period (0-based)  \ngub: Treatment indicator (1 only on treatment day)\ndeath_rte: Outcome variable\npop_dens: Covariate","category":"page"},{"location":"tutorial.html#Step-1:-Model-Creation","page":"Tutorial","title":"Step 1: Model Creation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The makemodel function sets up your causal inference model:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"model = makemodel(\n    dat,              # Your data\n    :day,             # Time variable\n    :fips,            # Unit identifier  \n    :gub,             # Treatment variable\n    :death_rte,       # Outcome variable\n    [:pop_dens],      # Covariates for matching\n    Dict(:pop_dens => false),  # Which covariates are time-varying\n    5:10,             # F: Post-treatment periods to estimate\n    -15:-10           # L: Pre-treatment periods for matching\n)","category":"page"},{"location":"tutorial.html#Key-Parameters-Explained","page":"Tutorial","title":"Key Parameters Explained","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"F periods (5:10): How many periods after treatment to estimate effects\nL periods (-15:-10): Which pre-treatment periods to use for matching\nMust be negative for pre-treatment\nUsed to find similar control units\nTime-varying covariates: Set true if covariate changes over time","category":"page"},{"location":"tutorial.html#Step-2:-Matching","page":"Tutorial","title":"Step 2: Matching","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Find control units similar to treated units in pre-treatment periods:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"match!(model, dat)\n\n# Check how many matches were found\nprintln(\"Found matches for $(length(model.matches)) treated observations\")","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The matching algorithm:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Identifies treated units and their treatment times\nFinds control units with similar covariate values in pre-treatment periods\nCreates matched sets for each treated observation","category":"page"},{"location":"tutorial.html#Step-3:-Balancing","page":"Tutorial","title":"Step 3: Balancing","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Assess how well matching achieved covariate balance:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"balance!(model, dat)\n\n# Check balance results\nmodel.meanbalances","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Good balance means treated and control groups have similar covariate distributions in pre-treatment periods.","category":"page"},{"location":"tutorial.html#Step-4:-Estimation","page":"Tutorial","title":"Step 4: Estimation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Estimate average treatment effects with bootstrap inference:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Run estimation (without Bayesian factors for simplicity)\nestimate!(model, dat; dobayesfactor=false)\n\n# View results\nmodel.results","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Results include:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"f: Time periods relative to treatment\natt: Average treatment effect estimates\nq025, q975: 95% confidence intervals\ntreated: Number of treated units\nmatches: Number of control units matched","category":"page"},{"location":"tutorial.html#Interpreting-Results","page":"Tutorial","title":"Interpreting Results","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Look at results\nprintln(\"Treatment Effects by Time Period:\")\nselect(model.results, :f, :att, :q025, :q975)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Positive ATT: Treatment increased the outcome\nNegative ATT: Treatment decreased the outcome  \nConfidence intervals: Statistical uncertainty around estimates\nMultiple time periods: See how effects evolve over time","category":"page"},{"location":"tutorial.html#Complete-Example","page":"Tutorial","title":"Complete Example","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using TSCSMethods, DataFrames\n\n# 1. Load/generate data\ndat = example_data(n_units=30, n_days=60, seed=42)\n\n# 2. Create model  \nmodel = makemodel(dat, :day, :fips, :gub, :death_rte, \n                 [:pop_dens], Dict(:pop_dens => false),\n                 3:8, -20:-10)\n\n# 3. Run complete workflow\nmatch!(model, dat)\nbalance!(model, dat) \nestimate!(model, dat; dobayesfactor=false)\n\n# 4. Examine results\nprintln(\"Number of treated observations: \", model.treatednum)\nprintln(\"Average treatment effect in period 3: \", model.results[1, :att])","category":"page"}]
}
